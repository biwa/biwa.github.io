{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Index UDB script Getting started Changes API Angle2D BlockEntry BlockMap BlockMapQueryResult Data GameConfiguration ImageInfo Line2D Linedef Map Plane QueryOptions Sector Sidedef Thing Vector2D Vector3D Vertex Built-in libraries Pen","title":"Index"},{"location":"#index","text":"","title":"Index"},{"location":"#udb-script","text":"Getting started Changes","title":"UDB script"},{"location":"#api","text":"Angle2D BlockEntry BlockMap BlockMapQueryResult Data GameConfiguration ImageInfo Line2D Linedef Map Plane QueryOptions Sector Sidedef Thing Vector2D Vector3D Vertex","title":"API"},{"location":"#built-in-libraries","text":"Pen","title":"Built-in libraries"},{"location":"Angle2D/","text":"Angle2D Methods degToRad(deg: double) Converts degrees to radians. Parameters deg: Angle in degrees Return value Angle in radians doomToReal(doomangle: int) Converts a Doom angle (where 0\u00b0 is east) to a real world angle (where 0\u00b0 is north). Parameters doomangle: Doom angle in degrees Return value Doom angle in degrees doomToRealRad(doomangle: int) Converts a Doom angle (where 0\u00b0 is east) to a real world angle (where 0\u00b0 is north) in radians. Parameters doomangle: Doom angle in degrees Return value Doom angle in radians getAngle(p1: object, p2: object, p3: object) Returns the angle between three positions. Parameters p1: First position p2: Second position p3: Third position Return value Angle in degrees getAngleRad(p1: object, p2: object, p3: object) Returns the angle between three positions in radians. Parameters p1: First position p2: Second position p3: Third position Return value Angle in radians normalized(angle: int) Normalizes an angle in degrees so that it is bigger or equal to 0\u00b0 and smaller than 360\u00b0. Parameters angle: Angle in degrees Return value Normalized angle in degrees normalizedRad(angle: double) Normalizes an angle in radians so that it is bigger or equal to 0 and smaller than 2 Pi. Parameters angle: Angle in radians Return value Normalized angle in radians radToDeg(rad: double) Converts radians to degrees. Parameters rad: Angle in radians Return value Angle in degrees realToDoom(realangle: double) Converts a real world angle (where 0\u00b0 is north) to a Doom angle (where 0\u00b0 is east). Parameters realangle: Real world angle in degrees Return value Doom angle in degrees realToDoomRad(realangle: double) Converts a real world angle (where 0\u00b0 is north) to a Doom angle (where 0\u00b0 is east) in radians. Parameters realangle: Real world angle in radians Return value Doom angle in degrees","title":"Angle2D"},{"location":"Angle2D/#angle2d","text":"","title":"Angle2D"},{"location":"Angle2D/#methods","text":"","title":"Methods"},{"location":"Angle2D/#degtoraddeg-double","text":"Converts degrees to radians.","title":"degToRad(deg: double)"},{"location":"Angle2D/#parameters","text":"deg: Angle in degrees","title":"Parameters"},{"location":"Angle2D/#return-value","text":"Angle in radians","title":"Return value"},{"location":"Angle2D/#doomtorealdoomangle-int","text":"Converts a Doom angle (where 0\u00b0 is east) to a real world angle (where 0\u00b0 is north).","title":"doomToReal(doomangle: int)"},{"location":"Angle2D/#parameters_1","text":"doomangle: Doom angle in degrees","title":"Parameters"},{"location":"Angle2D/#return-value_1","text":"Doom angle in degrees","title":"Return value"},{"location":"Angle2D/#doomtorealraddoomangle-int","text":"Converts a Doom angle (where 0\u00b0 is east) to a real world angle (where 0\u00b0 is north) in radians.","title":"doomToRealRad(doomangle: int)"},{"location":"Angle2D/#parameters_2","text":"doomangle: Doom angle in degrees","title":"Parameters"},{"location":"Angle2D/#return-value_2","text":"Doom angle in radians","title":"Return value"},{"location":"Angle2D/#getanglep1-object-p2-object-p3-object","text":"Returns the angle between three positions.","title":"getAngle(p1: object, p2: object, p3: object)"},{"location":"Angle2D/#parameters_3","text":"p1: First position p2: Second position p3: Third position","title":"Parameters"},{"location":"Angle2D/#return-value_3","text":"Angle in degrees","title":"Return value"},{"location":"Angle2D/#getangleradp1-object-p2-object-p3-object","text":"Returns the angle between three positions in radians.","title":"getAngleRad(p1: object, p2: object, p3: object)"},{"location":"Angle2D/#parameters_4","text":"p1: First position p2: Second position p3: Third position","title":"Parameters"},{"location":"Angle2D/#return-value_4","text":"Angle in radians","title":"Return value"},{"location":"Angle2D/#normalizedangle-int","text":"Normalizes an angle in degrees so that it is bigger or equal to 0\u00b0 and smaller than 360\u00b0.","title":"normalized(angle: int)"},{"location":"Angle2D/#parameters_5","text":"angle: Angle in degrees","title":"Parameters"},{"location":"Angle2D/#return-value_5","text":"Normalized angle in degrees","title":"Return value"},{"location":"Angle2D/#normalizedradangle-double","text":"Normalizes an angle in radians so that it is bigger or equal to 0 and smaller than 2 Pi.","title":"normalizedRad(angle: double)"},{"location":"Angle2D/#parameters_6","text":"angle: Angle in radians","title":"Parameters"},{"location":"Angle2D/#return-value_6","text":"Normalized angle in radians","title":"Return value"},{"location":"Angle2D/#radtodegrad-double","text":"Converts radians to degrees.","title":"radToDeg(rad: double)"},{"location":"Angle2D/#parameters_7","text":"rad: Angle in radians","title":"Parameters"},{"location":"Angle2D/#return-value_7","text":"Angle in degrees","title":"Return value"},{"location":"Angle2D/#realtodoomrealangle-double","text":"Converts a real world angle (where 0\u00b0 is north) to a Doom angle (where 0\u00b0 is east).","title":"realToDoom(realangle: double)"},{"location":"Angle2D/#parameters_8","text":"realangle: Real world angle in degrees","title":"Parameters"},{"location":"Angle2D/#return-value_8","text":"Doom angle in degrees","title":"Return value"},{"location":"Angle2D/#realtodoomradrealangle-double","text":"Converts a real world angle (where 0\u00b0 is north) to a Doom angle (where 0\u00b0 is east) in radians.","title":"realToDoomRad(realangle: double)"},{"location":"Angle2D/#parameters_9","text":"realangle: Real world angle in radians","title":"Parameters"},{"location":"Angle2D/#return-value_9","text":"Doom angle in degrees","title":"Return value"},{"location":"BlockEntry/","text":"BlockEntry A BlockEntry is a single block in a BlockMap . It has methods to retrieve the linedefs, things, sectors, and vertices that are in this block. Methods Version: 5 getLinedefs() Gets all Linedef s in the blockmap entry. Return value Array of Linedef s Version: 5 getSectors() Gets all Sector s in the blockmap entry. Return value Array of Sector s Version: 5 getThings() Gets all Thing s in the blockmap entry. Return value Array of Thing s Version: 5 getVertices() Gets all Vertex in the blockmap entry. Return value Array of Vertex","title":"BlockEntry"},{"location":"BlockEntry/#blockentry","text":"A BlockEntry is a single block in a BlockMap . It has methods to retrieve the linedefs, things, sectors, and vertices that are in this block.","title":"BlockEntry"},{"location":"BlockEntry/#methods","text":"Version: 5","title":"Methods"},{"location":"BlockEntry/#getlinedefs","text":"Gets all Linedef s in the blockmap entry.","title":"getLinedefs()"},{"location":"BlockEntry/#return-value","text":"Array of Linedef s Version: 5","title":"Return value"},{"location":"BlockEntry/#getsectors","text":"Gets all Sector s in the blockmap entry.","title":"getSectors()"},{"location":"BlockEntry/#return-value_1","text":"Array of Sector s Version: 5","title":"Return value"},{"location":"BlockEntry/#getthings","text":"Gets all Thing s in the blockmap entry.","title":"getThings()"},{"location":"BlockEntry/#return-value_2","text":"Array of Thing s Version: 5","title":"Return value"},{"location":"BlockEntry/#getvertices","text":"Gets all Vertex in the blockmap entry.","title":"getVertices()"},{"location":"BlockEntry/#return-value_3","text":"Array of Vertex","title":"Return value"},{"location":"BlockMap/","text":"BlockMap A blockmap is used to retrieve a collection of localized map elements (things, linedefs, sectors, vertices). It can help to significantly speed up costly computations that would otherwise be applied to a large portion of the map elements. The blockmap divides the map into rectangular blocks and computes which map elements are fully or partially in each block. Then you can query the blockmap about only some of those blocks, and perform any further actions only on the map elements that are in those blocks. If you for example wanted to find out which sector is at the (0, 0) position you could write something like this without using a blockmap: UDB.Map.getSectors().findIndex((s, i) => { if(s.intersect([ 0, 0 ])) { UDB.log(`Found ${s} after ${i} tries.`) return true; } }); This loops through all sectors of the map and uses the intersect method to test if the point is inside the sector. While intersect is quite fast on its own, doing it potentially thousands of times adds up quickly, especially if you have to loop through all sectors multiple times. A pretty extreme example for this is the map Bastion of Chaos. The map contains nearly 32500 sectors, and the sector at (0, 0) is number 25499. That means that the above script has to run intersect on 25499 sectors, even on those that are not remotely near the (0, 0) position. Using a blockmap the code could look like this: const blockmap = new UDB.BlockMap(); blockmap.getBlockAt([ 0, 0 ]).getSectors().findIndex((s, i) => { if (s.intersect([0, 0])) { UDB.log(`Found ${s} after ${i} tries.`) return true; } }); As you can see the code is quite similar, the difference being that a blockmap is created, and UDB.Map is replaced by blockmap.getBlockAt([ 0, 0 ]) , the latter only getting a single block from the blockmap, that only contains the map elements that are in this block. Taking Bastion of Chaos as an example again, this code finds the sector after only 20 checks, instead of the 25499 checks in the first code example. Note Creating a blockmap has a small overhead, since it has to compute which map elements are in which blocks. This overhead, however, is quickly compensated by the time saved by not looping through irrelevant map elements. You can decrease this overhead by using a BlockMap constructor that only adds certain map element types to the blockmap. Constructors Version: 5 BlockMap() Creates a blockmap that includes linedefs, things, sectors, and vertices. // Create a blockmap that includes all linedefs, things, sectors, and vertices const blockmap = new UDB.BlockMap(); BlockMap(lines: bool, things: bool, sectors: bool, vertices: bool) Creates a blockmap that only includes certain map element types. // Create a blockmap that only includes sectors const blockmap = new UDB.BlockMap(false, false, true, false); Parameters lines: If linedefs should be added or not things: If thigs should be added or not sectors: If sectors should be added or not vertices: If vertices should be added or not Methods Version: 5 getBlockAt(pos: object) Gets the BlockEntry at a point. The given point can be a Vector2D or an Array of two numbers. const blockmap = new UDB.BlockMap(); const blockentry = blockmap.getBlockAt([ 64, 128 ]); Parameters pos: The point to get the BlockEntry of Return value The BlockEntry on the given point Version: 5 getLineBlocks(v1: object, v2: object) Gets a BlockMapQueryResult for the blockmap along a line between two points. The given points can be Vector2D s or an Array s of two numbers. const blockmap = new UDB.BlockMap(); const result = blockmap.getLineBlocks([ 0, 0 ], [ 512, 256 ]); Parameters v1: The first point v2: The second point Return value The BlockMapQueryResult for the line between the two points Version: 5 getRectangleBlocks(x: int, y: int, width: int, height: int) Gets a BlockMapQueryResult for the blockmap in a rectangle. const blockmap = new UDB.BlockMap(); const result = blockmap.getRectangleBlocks(0, 0, 512, 256); Parameters x: X position of the top-left corner of the rectangle y: Y position of the top-left corner of the rectangle width: Width of the rectangle height: Height of the rectangle Return value missing","title":"BlockMap"},{"location":"BlockMap/#blockmap","text":"A blockmap is used to retrieve a collection of localized map elements (things, linedefs, sectors, vertices). It can help to significantly speed up costly computations that would otherwise be applied to a large portion of the map elements. The blockmap divides the map into rectangular blocks and computes which map elements are fully or partially in each block. Then you can query the blockmap about only some of those blocks, and perform any further actions only on the map elements that are in those blocks. If you for example wanted to find out which sector is at the (0, 0) position you could write something like this without using a blockmap: UDB.Map.getSectors().findIndex((s, i) => { if(s.intersect([ 0, 0 ])) { UDB.log(`Found ${s} after ${i} tries.`) return true; } }); This loops through all sectors of the map and uses the intersect method to test if the point is inside the sector. While intersect is quite fast on its own, doing it potentially thousands of times adds up quickly, especially if you have to loop through all sectors multiple times. A pretty extreme example for this is the map Bastion of Chaos. The map contains nearly 32500 sectors, and the sector at (0, 0) is number 25499. That means that the above script has to run intersect on 25499 sectors, even on those that are not remotely near the (0, 0) position. Using a blockmap the code could look like this: const blockmap = new UDB.BlockMap(); blockmap.getBlockAt([ 0, 0 ]).getSectors().findIndex((s, i) => { if (s.intersect([0, 0])) { UDB.log(`Found ${s} after ${i} tries.`) return true; } }); As you can see the code is quite similar, the difference being that a blockmap is created, and UDB.Map is replaced by blockmap.getBlockAt([ 0, 0 ]) , the latter only getting a single block from the blockmap, that only contains the map elements that are in this block. Taking Bastion of Chaos as an example again, this code finds the sector after only 20 checks, instead of the 25499 checks in the first code example. Note Creating a blockmap has a small overhead, since it has to compute which map elements are in which blocks. This overhead, however, is quickly compensated by the time saved by not looping through irrelevant map elements. You can decrease this overhead by using a BlockMap constructor that only adds certain map element types to the blockmap.","title":"BlockMap"},{"location":"BlockMap/#constructors","text":"Version: 5","title":"Constructors"},{"location":"BlockMap/#blockmap_1","text":"Creates a blockmap that includes linedefs, things, sectors, and vertices. // Create a blockmap that includes all linedefs, things, sectors, and vertices const blockmap = new UDB.BlockMap();","title":"BlockMap()"},{"location":"BlockMap/#blockmaplines-bool-things-bool-sectors-bool-vertices-bool","text":"Creates a blockmap that only includes certain map element types. // Create a blockmap that only includes sectors const blockmap = new UDB.BlockMap(false, false, true, false);","title":"BlockMap(lines: bool, things: bool, sectors: bool, vertices: bool)"},{"location":"BlockMap/#parameters","text":"lines: If linedefs should be added or not things: If thigs should be added or not sectors: If sectors should be added or not vertices: If vertices should be added or not","title":"Parameters"},{"location":"BlockMap/#methods","text":"Version: 5","title":"Methods"},{"location":"BlockMap/#getblockatpos-object","text":"Gets the BlockEntry at a point. The given point can be a Vector2D or an Array of two numbers. const blockmap = new UDB.BlockMap(); const blockentry = blockmap.getBlockAt([ 64, 128 ]);","title":"getBlockAt(pos: object)"},{"location":"BlockMap/#parameters_1","text":"pos: The point to get the BlockEntry of","title":"Parameters"},{"location":"BlockMap/#return-value","text":"The BlockEntry on the given point Version: 5","title":"Return value"},{"location":"BlockMap/#getlineblocksv1-object-v2-object","text":"Gets a BlockMapQueryResult for the blockmap along a line between two points. The given points can be Vector2D s or an Array s of two numbers. const blockmap = new UDB.BlockMap(); const result = blockmap.getLineBlocks([ 0, 0 ], [ 512, 256 ]);","title":"getLineBlocks(v1: object, v2: object)"},{"location":"BlockMap/#parameters_2","text":"v1: The first point v2: The second point","title":"Parameters"},{"location":"BlockMap/#return-value_1","text":"The BlockMapQueryResult for the line between the two points Version: 5","title":"Return value"},{"location":"BlockMap/#getrectangleblocksx-int-y-int-width-int-height-int","text":"Gets a BlockMapQueryResult for the blockmap in a rectangle. const blockmap = new UDB.BlockMap(); const result = blockmap.getRectangleBlocks(0, 0, 512, 256);","title":"getRectangleBlocks(x: int, y: int, width: int, height: int)"},{"location":"BlockMap/#parameters_3","text":"x: X position of the top-left corner of the rectangle y: Y position of the top-left corner of the rectangle width: Width of the rectangle height: Height of the rectangle","title":"Parameters"},{"location":"BlockMap/#return-value_2","text":"missing","title":"Return value"},{"location":"BlockMapQueryResult/","text":"BlockMapQueryResult A BlockMapQueryResult is an object returned by the getLineBlocks and getRectangleBlocks methods of the BlockMap class. It has methods It has methods to retrieve the linedefs, things, sectors, and vertices that are in the queried blocks. The object is also iterable, returning each block, in cases where more fine-grained control is needed. const blockmap = new UDB.BlockMap(); const result = blockmap.getLineBlocks([ 0, 0 ], [ 512, 256 ]); // Print all linedefs in the blocks result.getLinedefs().forEach(ld => UDB.log(ld)); Looping over each block: const blockmap = new UDB.BlockMap(); const result = blockmap.getLineBlocks([ 0, 0 ], [ 512, 256 ]); for(const block of result) { UDB.log('--- New block ---'); block.getLinedefs().forEach(ld => UDB.log(ld)); } Note The methods to retrieve map elements from BlockMapQueryResult return arrays that only contain each map element once, since linedefs and sectors can be in multiple blocks, looping over a BlockMapQueryResult using for...of can return the same map elements multiple times. Methods Version: 5 getLinedefs() Gets all Linedef s in the blockmap query result. Return value Array of Linedef s Version: 5 getSectors() Gets all Sector s in the blockmap query result. Return value Array of Sector s Version: 5 getThings() Gets all Thing s in the blockmap query result. Return value Array of Thing s Version: 5 getVertices() Gets all Vertex in the blockmap query result. Return value Array of Vertex","title":"BlockMapQueryResult"},{"location":"BlockMapQueryResult/#blockmapqueryresult","text":"A BlockMapQueryResult is an object returned by the getLineBlocks and getRectangleBlocks methods of the BlockMap class. It has methods It has methods to retrieve the linedefs, things, sectors, and vertices that are in the queried blocks. The object is also iterable, returning each block, in cases where more fine-grained control is needed. const blockmap = new UDB.BlockMap(); const result = blockmap.getLineBlocks([ 0, 0 ], [ 512, 256 ]); // Print all linedefs in the blocks result.getLinedefs().forEach(ld => UDB.log(ld)); Looping over each block: const blockmap = new UDB.BlockMap(); const result = blockmap.getLineBlocks([ 0, 0 ], [ 512, 256 ]); for(const block of result) { UDB.log('--- New block ---'); block.getLinedefs().forEach(ld => UDB.log(ld)); } Note The methods to retrieve map elements from BlockMapQueryResult return arrays that only contain each map element once, since linedefs and sectors can be in multiple blocks, looping over a BlockMapQueryResult using for...of can return the same map elements multiple times.","title":"BlockMapQueryResult"},{"location":"BlockMapQueryResult/#methods","text":"Version: 5","title":"Methods"},{"location":"BlockMapQueryResult/#getlinedefs","text":"Gets all Linedef s in the blockmap query result.","title":"getLinedefs()"},{"location":"BlockMapQueryResult/#return-value","text":"Array of Linedef s Version: 5","title":"Return value"},{"location":"BlockMapQueryResult/#getsectors","text":"Gets all Sector s in the blockmap query result.","title":"getSectors()"},{"location":"BlockMapQueryResult/#return-value_1","text":"Array of Sector s Version: 5","title":"Return value"},{"location":"BlockMapQueryResult/#getthings","text":"Gets all Thing s in the blockmap query result.","title":"getThings()"},{"location":"BlockMapQueryResult/#return-value_2","text":"Array of Thing s Version: 5","title":"Return value"},{"location":"BlockMapQueryResult/#getvertices","text":"Gets all Vertex in the blockmap query result.","title":"getVertices()"},{"location":"BlockMapQueryResult/#return-value_3","text":"Array of Vertex","title":"Return value"},{"location":"Data/","text":"Data Methods flatExists(name: string) Checks if a flat with the given name exists. Parameters name: Flat name to check Return value true if the flat exists, false if it doesn't getFlatInfo(name: string) Returns an ImageInfo object for the given flat name. Parameters name: Flat name to get the info for Return value ImageInfo object containing information about the flat getFlatNames() Returns an Array of all flat names. Return value Array of all flat names getTextureInfo(name: string) Returns an ImageInfo object for the given texture name. Parameters name: Texture name to get the info for Return value ImageInfo object containing information about the texture getTextureNames() Returns an Array of all texture names. Return value Array of all texture names textureExists(name: string) Checks if a texture with the given name exists. Parameters name: Texture name to check Return value true if the texture exists, false if it doesn't","title":"Data"},{"location":"Data/#data","text":"","title":"Data"},{"location":"Data/#methods","text":"","title":"Methods"},{"location":"Data/#flatexistsname-string","text":"Checks if a flat with the given name exists.","title":"flatExists(name: string)"},{"location":"Data/#parameters","text":"name: Flat name to check","title":"Parameters"},{"location":"Data/#return-value","text":"true if the flat exists, false if it doesn't","title":"Return value"},{"location":"Data/#getflatinfoname-string","text":"Returns an ImageInfo object for the given flat name.","title":"getFlatInfo(name: string)"},{"location":"Data/#parameters_1","text":"name: Flat name to get the info for","title":"Parameters"},{"location":"Data/#return-value_1","text":"ImageInfo object containing information about the flat","title":"Return value"},{"location":"Data/#getflatnames","text":"Returns an Array of all flat names.","title":"getFlatNames()"},{"location":"Data/#return-value_2","text":"Array of all flat names","title":"Return value"},{"location":"Data/#gettextureinfoname-string","text":"Returns an ImageInfo object for the given texture name.","title":"getTextureInfo(name: string)"},{"location":"Data/#parameters_2","text":"name: Texture name to get the info for","title":"Parameters"},{"location":"Data/#return-value_3","text":"ImageInfo object containing information about the texture","title":"Return value"},{"location":"Data/#gettexturenames","text":"Returns an Array of all texture names.","title":"getTextureNames()"},{"location":"Data/#return-value_4","text":"Array of all texture names","title":"Return value"},{"location":"Data/#textureexistsname-string","text":"Checks if a texture with the given name exists.","title":"textureExists(name: string)"},{"location":"Data/#parameters_3","text":"name: Texture name to check","title":"Parameters"},{"location":"Data/#return-value_5","text":"true if the texture exists, false if it doesn't","title":"Return value"},{"location":"GameConfiguration/","text":"GameConfiguration Properties engineName Engine name, like doom , boom , zdoom etc. Used for the namespace in UDMF maps. Read-only. hasLocalSidedefTextureOffsets If the game configuration supports local sidedef texture offsets (distinct offsets for upper, middle, and lower sidedef parts).","title":"GameConfiguration"},{"location":"GameConfiguration/#gameconfiguration","text":"","title":"GameConfiguration"},{"location":"GameConfiguration/#properties","text":"","title":"Properties"},{"location":"GameConfiguration/#enginename","text":"Engine name, like doom , boom , zdoom etc. Used for the namespace in UDMF maps. Read-only.","title":"engineName"},{"location":"GameConfiguration/#haslocalsidedeftextureoffsets","text":"If the game configuration supports local sidedef texture offsets (distinct offsets for upper, middle, and lower sidedef parts).","title":"hasLocalSidedefTextureOffsets"},{"location":"ImageInfo/","text":"ImageInfo Properties height Height of the image. isFlat If the image is a flat ( true ) or not ( false ). name Name of the image. scale Scale of the image as Vector2D . width Width of the image.","title":"ImageInfo"},{"location":"ImageInfo/#imageinfo","text":"","title":"ImageInfo"},{"location":"ImageInfo/#properties","text":"","title":"Properties"},{"location":"ImageInfo/#height","text":"Height of the image.","title":"height"},{"location":"ImageInfo/#isflat","text":"If the image is a flat ( true ) or not ( false ).","title":"isFlat"},{"location":"ImageInfo/#name","text":"Name of the image.","title":"name"},{"location":"ImageInfo/#scale","text":"Scale of the image as Vector2D .","title":"scale"},{"location":"ImageInfo/#width","text":"Width of the image.","title":"width"},{"location":"Line2D/","text":"Line2D Constructors Line2D(v1: object, v2: object) Creates a new Line2D from two points. let line1 = new UDB.Line2D(new Vector2D(32, 64), new Vector2D(96, 128)); let line2 = new UDB.Line2D([ 32, 64 ], [ 96, 128 ]); Parameters v1: First point v2: Second point Static methods areIntersecting(line1: Line2D, line2: Line2D, bounded: bool) Checks if two lines intersect. If bounded is set to true (default) the finite length of the lines is used, otherwise the infinite length of the lines is used. Parameters line1: First Line2D line2: Second Line2D bounded: true to use finite length of lines, false to use infinite length of lines Return value true if the lines intersect, false if they do not areIntersecting(a1: object, a2: object, b1: object, b2: object, bounded: bool) Checks if two lines defined by their start and end points intersect. If bounded is set to true (default) the finite length of the lines is used, otherwise the infinite length of the lines is used. Parameters a1: First point of first line a2: Second point of first line b1: First point of second line b2: Second point of second line bounded: true (default) to use finite length of lines, false to use infinite length of lines Return value true if the lines intersect, false if they do not getCoordinatesAt(v1: object, v2: object, u: double) Returns the coordinate on a line defined by its start and end points as Vector2D . Parameters v1: First point of the line v2: Second point of the line u: Offset coordinate relative to the first point of the line Return value Point on the line as Vector2D getDistanceToLine(v1: object, v2: object, p: object, bounded: bool) Returns the shortest distance from point p to the line defined by its start and end points. If bounded is set to true (default) the finite length of the lines is used, otherwise the infinite length of the lines is used. Parameters v1: First point of the line v2: Second point of the line p: Point to get the distance to bounded: true (default) to use finite length of lines, false to use infinite length of lines Return value The shortest distance to the line getDistanceToLineSq(v1: object, v2: object, p: object, bounded: bool) Returns the shortest square distance from point p to the line defined by its start and end points. If bounded is set to true (default) the finite length of the lines is used, otherwise the infinite length of the lines is used. Parameters v1: First point of the line v2: Second point of the line p: Point to get the distance to bounded: true (default) to use finite length of lines, false to use infinite length of lines Return value The shortest square distance to the line getIntersectionPoint(a1: object, a2: object, b1: object, b2: object, bounded: bool) Returns the intersection point of two lines as Vector2D . If the lines do not intersect the x and y properties of the Vector2D are NaN . If bounded is set to true (default) the finite length of the lines is used, otherwise the infinite length of the lines is used. Parameters a1: First point of first line a2: Second point of first line b1: First point of second line b2: Second point of second line bounded: true (default) to use finite length of lines, false to use infinite length of lines Return value The intersection point as Vector2D getNearestOnLine(v1: object, v2: object, p: object) Returns the offset coordinate on the line nearest to the given point. 0.0 being on the first point, 1.0 being on the second point, and u = 0.5 being in the middle between the points. Parameters v1: First point of the line v2: Second point of the line p: Point to get the nearest offset coordinate from Return value The offset value relative to the first point of the line. getSideOfLine(v1: object, v2: object, p: object) Returns which the of the line defined by its start and end point a given point is on. Parameters v1: First point of the line v2: Second point of the line p: Point to check Return value < 0 if p is on the front (right) side, > 0 if p is on the back (left) side, == 0 if p in on the line Properties v1 Vector2D position of start of the line. v2 Vector2D position of end of the line. Methods getAngle() Return the angle of the Line2D in degrees. Return value Angle of the Line2D in degrees getAngleRad() Returns the angle of the Line2D in radians. Return value Angle of Line2D in radians getCoordinatesAt(u: double) Returns the coordinates on the line, where u is the position between the first and second point, u = 0.0 being on the first point, u = 1.0 being on the second point, and u = 0.5 being in the middle between the points. Parameters u: Position on the line, between 0.0 and 1.0 Return value Position on the line as Vector2D getIntersectionPoint(a1: object, a2: object, bounded: bool) Returns the intersection point of of the given line defined by its start and end points with this line as Vector2D . If the lines do not intersect the x and y properties of the Vector2D are NaN . If bounded is set to true (default) the finite length of the lines is used, otherwise the infinite length of the lines is used. Parameters a1: First point of first line a2: Second point of first line bounded: true (default) to use finite length of lines, false to use infinite length of lines Return value The intersection point as Vector2D getIntersectionPoint(ray: Line2D, bounded: bool) Returns the intersection point of of the given line with this line as Vector2D . If the lines do not intersect the x and y properties of the Vector2D are NaN . If bounded is set to true (default) the finite length of the lines is used, otherwise the infinite length of the lines is used. Parameters ray: Other Line2D to get the intersection point from bounded: true (default) to use finite length of lines, false to use infinite length of lines Return value The intersection point as Vector2D getLength() Returns the length of the Line2D . Return value Length of the Line2D getPerpendicular() Returns the perpendicular of this line as Vector2D . Return value Perpendicular of this line as Vector2D getSideOfLine(p: object) Returns which the of the line defined by its start and end point a given point is on. Parameters p: Point to check Return value < 0 if p is on the front (right) side, > 0 if p is on the back (left) side, == 0 if p in on the line isIntersecting(ray: Line2D, bounded: bool) Checks if the given Line2D intersects this line. If bounded is set to true (default) the finite length of the lines is used, otherwise the infinite length of the lines is used. Parameters ray: Line2D to check against bounded: true (default) to use finite length of lines, false to use infinite length of lines Return value true if lines intersect, false if they do not intersect isIntersecting(a1: object, a2: object, bounded: bool) Checks if the given line intersects this line. If bounded is set to true (default) the finite length of the lines is used, otherwise the infinite length of the lines is used. Parameters a1: First point of the line to check against a2: Second point of the line to check against bounded: true (default) to use finite length of lines, false to use infinite length of lines Return value true if the lines intersect, false if they do not","title":"Line2D"},{"location":"Line2D/#line2d","text":"","title":"Line2D"},{"location":"Line2D/#constructors","text":"","title":"Constructors"},{"location":"Line2D/#line2dv1-object-v2-object","text":"Creates a new Line2D from two points. let line1 = new UDB.Line2D(new Vector2D(32, 64), new Vector2D(96, 128)); let line2 = new UDB.Line2D([ 32, 64 ], [ 96, 128 ]);","title":"Line2D(v1: object, v2: object)"},{"location":"Line2D/#parameters","text":"v1: First point v2: Second point","title":"Parameters"},{"location":"Line2D/#static-methods","text":"","title":"Static methods"},{"location":"Line2D/#areintersectingline1-line2d-line2-line2d-bounded-bool","text":"Checks if two lines intersect. If bounded is set to true (default) the finite length of the lines is used, otherwise the infinite length of the lines is used.","title":"areIntersecting(line1: Line2D, line2: Line2D, bounded: bool)"},{"location":"Line2D/#parameters_1","text":"line1: First Line2D line2: Second Line2D bounded: true to use finite length of lines, false to use infinite length of lines","title":"Parameters"},{"location":"Line2D/#return-value","text":"true if the lines intersect, false if they do not","title":"Return value"},{"location":"Line2D/#areintersectinga1-object-a2-object-b1-object-b2-object-bounded-bool","text":"Checks if two lines defined by their start and end points intersect. If bounded is set to true (default) the finite length of the lines is used, otherwise the infinite length of the lines is used.","title":"areIntersecting(a1: object, a2: object, b1: object, b2: object, bounded: bool)"},{"location":"Line2D/#parameters_2","text":"a1: First point of first line a2: Second point of first line b1: First point of second line b2: Second point of second line bounded: true (default) to use finite length of lines, false to use infinite length of lines","title":"Parameters"},{"location":"Line2D/#return-value_1","text":"true if the lines intersect, false if they do not","title":"Return value"},{"location":"Line2D/#getcoordinatesatv1-object-v2-object-u-double","text":"Returns the coordinate on a line defined by its start and end points as Vector2D .","title":"getCoordinatesAt(v1: object, v2: object, u: double)"},{"location":"Line2D/#parameters_3","text":"v1: First point of the line v2: Second point of the line u: Offset coordinate relative to the first point of the line","title":"Parameters"},{"location":"Line2D/#return-value_2","text":"Point on the line as Vector2D","title":"Return value"},{"location":"Line2D/#getdistancetolinev1-object-v2-object-p-object-bounded-bool","text":"Returns the shortest distance from point p to the line defined by its start and end points. If bounded is set to true (default) the finite length of the lines is used, otherwise the infinite length of the lines is used.","title":"getDistanceToLine(v1: object, v2: object, p: object, bounded: bool)"},{"location":"Line2D/#parameters_4","text":"v1: First point of the line v2: Second point of the line p: Point to get the distance to bounded: true (default) to use finite length of lines, false to use infinite length of lines","title":"Parameters"},{"location":"Line2D/#return-value_3","text":"The shortest distance to the line","title":"Return value"},{"location":"Line2D/#getdistancetolinesqv1-object-v2-object-p-object-bounded-bool","text":"Returns the shortest square distance from point p to the line defined by its start and end points. If bounded is set to true (default) the finite length of the lines is used, otherwise the infinite length of the lines is used.","title":"getDistanceToLineSq(v1: object, v2: object, p: object, bounded: bool)"},{"location":"Line2D/#parameters_5","text":"v1: First point of the line v2: Second point of the line p: Point to get the distance to bounded: true (default) to use finite length of lines, false to use infinite length of lines","title":"Parameters"},{"location":"Line2D/#return-value_4","text":"The shortest square distance to the line","title":"Return value"},{"location":"Line2D/#getintersectionpointa1-object-a2-object-b1-object-b2-object-bounded-bool","text":"Returns the intersection point of two lines as Vector2D . If the lines do not intersect the x and y properties of the Vector2D are NaN . If bounded is set to true (default) the finite length of the lines is used, otherwise the infinite length of the lines is used.","title":"getIntersectionPoint(a1: object, a2: object, b1: object, b2: object, bounded: bool)"},{"location":"Line2D/#parameters_6","text":"a1: First point of first line a2: Second point of first line b1: First point of second line b2: Second point of second line bounded: true (default) to use finite length of lines, false to use infinite length of lines","title":"Parameters"},{"location":"Line2D/#return-value_5","text":"The intersection point as Vector2D","title":"Return value"},{"location":"Line2D/#getnearestonlinev1-object-v2-object-p-object","text":"Returns the offset coordinate on the line nearest to the given point. 0.0 being on the first point, 1.0 being on the second point, and u = 0.5 being in the middle between the points.","title":"getNearestOnLine(v1: object, v2: object, p: object)"},{"location":"Line2D/#parameters_7","text":"v1: First point of the line v2: Second point of the line p: Point to get the nearest offset coordinate from","title":"Parameters"},{"location":"Line2D/#return-value_6","text":"The offset value relative to the first point of the line.","title":"Return value"},{"location":"Line2D/#getsideoflinev1-object-v2-object-p-object","text":"Returns which the of the line defined by its start and end point a given point is on.","title":"getSideOfLine(v1: object, v2: object, p: object)"},{"location":"Line2D/#parameters_8","text":"v1: First point of the line v2: Second point of the line p: Point to check","title":"Parameters"},{"location":"Line2D/#return-value_7","text":"< 0 if p is on the front (right) side, > 0 if p is on the back (left) side, == 0 if p in on the line","title":"Return value"},{"location":"Line2D/#properties","text":"","title":"Properties"},{"location":"Line2D/#v1","text":"Vector2D position of start of the line.","title":"v1"},{"location":"Line2D/#v2","text":"Vector2D position of end of the line.","title":"v2"},{"location":"Line2D/#methods","text":"","title":"Methods"},{"location":"Line2D/#getangle","text":"Return the angle of the Line2D in degrees.","title":"getAngle()"},{"location":"Line2D/#return-value_8","text":"Angle of the Line2D in degrees","title":"Return value"},{"location":"Line2D/#getanglerad","text":"Returns the angle of the Line2D in radians.","title":"getAngleRad()"},{"location":"Line2D/#return-value_9","text":"Angle of Line2D in radians","title":"Return value"},{"location":"Line2D/#getcoordinatesatu-double","text":"Returns the coordinates on the line, where u is the position between the first and second point, u = 0.0 being on the first point, u = 1.0 being on the second point, and u = 0.5 being in the middle between the points.","title":"getCoordinatesAt(u: double)"},{"location":"Line2D/#parameters_9","text":"u: Position on the line, between 0.0 and 1.0","title":"Parameters"},{"location":"Line2D/#return-value_10","text":"Position on the line as Vector2D","title":"Return value"},{"location":"Line2D/#getintersectionpointa1-object-a2-object-bounded-bool","text":"Returns the intersection point of of the given line defined by its start and end points with this line as Vector2D . If the lines do not intersect the x and y properties of the Vector2D are NaN . If bounded is set to true (default) the finite length of the lines is used, otherwise the infinite length of the lines is used.","title":"getIntersectionPoint(a1: object, a2: object, bounded: bool)"},{"location":"Line2D/#parameters_10","text":"a1: First point of first line a2: Second point of first line bounded: true (default) to use finite length of lines, false to use infinite length of lines","title":"Parameters"},{"location":"Line2D/#return-value_11","text":"The intersection point as Vector2D","title":"Return value"},{"location":"Line2D/#getintersectionpointray-line2d-bounded-bool","text":"Returns the intersection point of of the given line with this line as Vector2D . If the lines do not intersect the x and y properties of the Vector2D are NaN . If bounded is set to true (default) the finite length of the lines is used, otherwise the infinite length of the lines is used.","title":"getIntersectionPoint(ray: Line2D, bounded: bool)"},{"location":"Line2D/#parameters_11","text":"ray: Other Line2D to get the intersection point from bounded: true (default) to use finite length of lines, false to use infinite length of lines","title":"Parameters"},{"location":"Line2D/#return-value_12","text":"The intersection point as Vector2D","title":"Return value"},{"location":"Line2D/#getlength","text":"Returns the length of the Line2D .","title":"getLength()"},{"location":"Line2D/#return-value_13","text":"Length of the Line2D","title":"Return value"},{"location":"Line2D/#getperpendicular","text":"Returns the perpendicular of this line as Vector2D .","title":"getPerpendicular()"},{"location":"Line2D/#return-value_14","text":"Perpendicular of this line as Vector2D","title":"Return value"},{"location":"Line2D/#getsideoflinep-object","text":"Returns which the of the line defined by its start and end point a given point is on.","title":"getSideOfLine(p: object)"},{"location":"Line2D/#parameters_12","text":"p: Point to check","title":"Parameters"},{"location":"Line2D/#return-value_15","text":"< 0 if p is on the front (right) side, > 0 if p is on the back (left) side, == 0 if p in on the line","title":"Return value"},{"location":"Line2D/#isintersectingray-line2d-bounded-bool","text":"Checks if the given Line2D intersects this line. If bounded is set to true (default) the finite length of the lines is used, otherwise the infinite length of the lines is used.","title":"isIntersecting(ray: Line2D, bounded: bool)"},{"location":"Line2D/#parameters_13","text":"ray: Line2D to check against bounded: true (default) to use finite length of lines, false to use infinite length of lines","title":"Parameters"},{"location":"Line2D/#return-value_16","text":"true if lines intersect, false if they do not intersect","title":"Return value"},{"location":"Line2D/#isintersectinga1-object-a2-object-bounded-bool","text":"Checks if the given line intersects this line. If bounded is set to true (default) the finite length of the lines is used, otherwise the infinite length of the lines is used.","title":"isIntersecting(a1: object, a2: object, bounded: bool)"},{"location":"Line2D/#parameters_14","text":"a1: First point of the line to check against a2: Second point of the line to check against bounded: true (default) to use finite length of lines, false to use infinite length of lines","title":"Parameters"},{"location":"Line2D/#return-value_17","text":"true if the lines intersect, false if they do not","title":"Return value"},{"location":"Linedef/","text":"Linedef Properties action Linedef action. activate The activation flag. Hexen format only. angle The Linedef 's angle in degree. Read-only. angleRad The Linedef 's angle in radians. Read-only. args Array of arguments of the Linedef . Number of arguments depends on game config (usually 5). Hexen format and UDMF only. back The Linedef 's back Sidedef . Is null when there is no back. end The linedef's end Vertex . fields UDMF fields. It's an object with the fields as properties. s.fields.comment = 'This is a comment'; s.fields['comment'] = 'This is a comment'; // Also works s.fields.xscalefloor = 2.0; t.fields.score = 100; It is also possible to define new fields: s.fields.user_myboolfield = true; There are some restrictions, though: it only works for fields that are not in the base UDMF standard, since those are handled directly in the respective class it does not work for flags. While they are technically also UDMF fields, they are handled in the flags field of the respective class (where applicable) JavaScript does not distinguish between integer and floating point numbers, it only has floating point numbers (of double precision). For fields where UDB knows that they are integers this it not a problem, since it'll automatically convert the floating point numbers to integers (dropping the fractional part). However, if you need to specify an integer value for an unknown or custom field you have to work around this limitation: Version 5 and later: You can use a BigInt . This is done by appending a n to the number. Note that this is just a convenient way to define whole numbers, it still only supports 32 bit integers: s.fields.user_myintfield = 25n; // Sets the 'user_myintfield' field to an integer value of 25 In version 4 and earlier you have to use the UniValue class: s.fields.user_myintfield = new UDB.UniValue(0, 25); // Sets the 'user_myintfield' field to an integer value of 25 To remove a field you have to assign null to it: s.fields.user_myintfield = null; flags Linedef flags. It's an object with the flags as properties. In Doom format and Hexen format they are identified by numbers, in UDMF by their name. Doom and Hexen: ld.flags['64'] = true; // Set the block sound flag UDMF: ld.flags['blocksound'] = true; // Set the block sound flag ld.flags.blocksound = true; // Also works front The Linedef 's front Sidedef . Is null when there is no front (should not happen). index The linedef's index. Read-only. length The Linedef 's length. Read-only. lengthInv 1.0 / length. Read-only. lengthSq The Linedef 's squared length. Read-only. line The Line2D from the start to the end Vertex . marked If the Linedef is marked or not. It is used to mark map elements that were created or changed (for example after drawing new geometry). selected If the Linedef is selected or not. start The linedef's start Vertex . tag Linedef tag. UDMF only. Methods addTag(tag: int) Adds a tag to the Linedef . UDMF only. Supported game configurations only. Parameters tag: Tag to add Return value true when the tag was added, false when the tag already exists applySidedFlags() Automatically sets the blocking and two-sided flags based on the existing Sidedef s. clearFlags() Clears all flags. copyPropertiesTo(other: Linedef) Copies the properties of this Linedef to another Linedef . Parameters other: The Linedef to copy the properties to delete() Deletes the Linedef . Note that this will result in unclosed Sector s unless it has the same Sector s on both sides. distanceTo(pos: object, bounded: bool) Gets the shortest distance from pos to the line. Parameters pos: Point to check against bounded: true if only the finite length of the line should be used, false if the infinite length of the line should be used Return value Distance to the line distanceToSq(pos: object, bounded: bool) Gets the shortest squared distance from pos to the line. Parameters pos: Point to check against bounded: true if only the finite length of the line should be used, false if the infinite length of the line should be used Return value Squared distance to the line flip() Flips the Linedef 's vertex attachments and Sidedef s. This is a shortcut to using both flipVertices() and flipSidedefs() . flipSidedefs() Flips the Linedef 's Sidedef s. flipVertices() Flips the Linedef 's vertex attachments. getCenterPoint() Gets a Vector2D that's in the center of the Linedef . Return value Vector2D in the center of the Linedef getSidePoint(front: bool) Gets a Vector2D for testing on one side. The Vector2D is on the front when true is passed, otherwise on the back. Parameters front: true for front, false for back Return value Vector2D that's either on the front of back of the Linedef getTags() Returns an Array of the Linedef 's tags. UDMF only. Supported game configurations only. Return value Array of tags nearestOnLine(pos: object) Get a Vector2D that's on the line, closest to pos . pos can either be a Vector2D , or an array of numbers. var v1 = ld.nearestOnLine(new Vector2D(32, 64)); var v2 = ld.nearestOnLine([ 32, 64 ]); Parameters pos: Point to check against Return value Vector2D that's on the linedef removeTag(tag: int) Removes a tag from the Linedef . UDMF only. Supported game configurations only. Parameters tag: Tag to remove Return value true when the tag was removed successfully, false when the tag did not exist safeDistanceTo(pos: object, bounded: bool) Gets the shortest \"safe\" distance from pos to the line. If bounded is true that means that the not the whole line's length will be used, but lengthInv less at the start and end. Parameters pos: Point to check against bounded: true if only the finite length of the line should be used, false if the infinite length of the line should be used Return value Distance to the line safeDistanceToSq(pos: object, bounded: bool) Gets the shortest \"safe\" squared distance from pos to the line. If bounded is true that means that the not the whole line's length will be used, but lengthInv less at the start and end. Parameters pos: Point to check against bounded: true if only the finite length of the line should be used, false if the infinite length of the line should be used Return value Squared distance to the line sideOfLine(pos: object) Tests which side of the Linedef pos is on. Returns < 0 for front (right) side, > for back (left) side, and 0 if pos is on the line. Parameters pos: Point to check against Return value < 0 for front (right) side, > for back (left) side, and 0 if pos is on the line split(pos: object) Splits the Linedef at the given position. This can either be a Vector2D , an array of numbers, or an existing Vertex . The result will be two lines, from the start Vertex of the Linedef to pos , and from pos to the end Vertex of the Linedef . Parameters pos: Vertex to split by Return value The newly created Linedef","title":"Linedef"},{"location":"Linedef/#linedef","text":"","title":"Linedef"},{"location":"Linedef/#properties","text":"","title":"Properties"},{"location":"Linedef/#action","text":"Linedef action.","title":"action"},{"location":"Linedef/#activate","text":"The activation flag. Hexen format only.","title":"activate"},{"location":"Linedef/#angle","text":"The Linedef 's angle in degree. Read-only.","title":"angle"},{"location":"Linedef/#anglerad","text":"The Linedef 's angle in radians. Read-only.","title":"angleRad"},{"location":"Linedef/#args","text":"Array of arguments of the Linedef . Number of arguments depends on game config (usually 5). Hexen format and UDMF only.","title":"args"},{"location":"Linedef/#back","text":"The Linedef 's back Sidedef . Is null when there is no back.","title":"back"},{"location":"Linedef/#end","text":"The linedef's end Vertex .","title":"end"},{"location":"Linedef/#fields","text":"UDMF fields. It's an object with the fields as properties. s.fields.comment = 'This is a comment'; s.fields['comment'] = 'This is a comment'; // Also works s.fields.xscalefloor = 2.0; t.fields.score = 100; It is also possible to define new fields: s.fields.user_myboolfield = true; There are some restrictions, though: it only works for fields that are not in the base UDMF standard, since those are handled directly in the respective class it does not work for flags. While they are technically also UDMF fields, they are handled in the flags field of the respective class (where applicable) JavaScript does not distinguish between integer and floating point numbers, it only has floating point numbers (of double precision). For fields where UDB knows that they are integers this it not a problem, since it'll automatically convert the floating point numbers to integers (dropping the fractional part). However, if you need to specify an integer value for an unknown or custom field you have to work around this limitation: Version 5 and later: You can use a BigInt . This is done by appending a n to the number. Note that this is just a convenient way to define whole numbers, it still only supports 32 bit integers: s.fields.user_myintfield = 25n; // Sets the 'user_myintfield' field to an integer value of 25 In version 4 and earlier you have to use the UniValue class: s.fields.user_myintfield = new UDB.UniValue(0, 25); // Sets the 'user_myintfield' field to an integer value of 25 To remove a field you have to assign null to it: s.fields.user_myintfield = null;","title":"fields"},{"location":"Linedef/#flags","text":"Linedef flags. It's an object with the flags as properties. In Doom format and Hexen format they are identified by numbers, in UDMF by their name. Doom and Hexen: ld.flags['64'] = true; // Set the block sound flag UDMF: ld.flags['blocksound'] = true; // Set the block sound flag ld.flags.blocksound = true; // Also works","title":"flags"},{"location":"Linedef/#front","text":"The Linedef 's front Sidedef . Is null when there is no front (should not happen).","title":"front"},{"location":"Linedef/#index","text":"The linedef's index. Read-only.","title":"index"},{"location":"Linedef/#length","text":"The Linedef 's length. Read-only.","title":"length"},{"location":"Linedef/#lengthinv","text":"1.0 / length. Read-only.","title":"lengthInv"},{"location":"Linedef/#lengthsq","text":"The Linedef 's squared length. Read-only.","title":"lengthSq"},{"location":"Linedef/#line","text":"The Line2D from the start to the end Vertex .","title":"line"},{"location":"Linedef/#marked","text":"If the Linedef is marked or not. It is used to mark map elements that were created or changed (for example after drawing new geometry).","title":"marked"},{"location":"Linedef/#selected","text":"If the Linedef is selected or not.","title":"selected"},{"location":"Linedef/#start","text":"The linedef's start Vertex .","title":"start"},{"location":"Linedef/#tag","text":"Linedef tag. UDMF only.","title":"tag"},{"location":"Linedef/#methods","text":"","title":"Methods"},{"location":"Linedef/#addtagtag-int","text":"Adds a tag to the Linedef . UDMF only. Supported game configurations only.","title":"addTag(tag: int)"},{"location":"Linedef/#parameters","text":"tag: Tag to add","title":"Parameters"},{"location":"Linedef/#return-value","text":"true when the tag was added, false when the tag already exists","title":"Return value"},{"location":"Linedef/#applysidedflags","text":"Automatically sets the blocking and two-sided flags based on the existing Sidedef s.","title":"applySidedFlags()"},{"location":"Linedef/#clearflags","text":"Clears all flags.","title":"clearFlags()"},{"location":"Linedef/#copypropertiestoother-linedef","text":"Copies the properties of this Linedef to another Linedef .","title":"copyPropertiesTo(other: Linedef)"},{"location":"Linedef/#parameters_1","text":"other: The Linedef to copy the properties to","title":"Parameters"},{"location":"Linedef/#delete","text":"Deletes the Linedef . Note that this will result in unclosed Sector s unless it has the same Sector s on both sides.","title":"delete()"},{"location":"Linedef/#distancetopos-object-bounded-bool","text":"Gets the shortest distance from pos to the line.","title":"distanceTo(pos: object, bounded: bool)"},{"location":"Linedef/#parameters_2","text":"pos: Point to check against bounded: true if only the finite length of the line should be used, false if the infinite length of the line should be used","title":"Parameters"},{"location":"Linedef/#return-value_1","text":"Distance to the line","title":"Return value"},{"location":"Linedef/#distancetosqpos-object-bounded-bool","text":"Gets the shortest squared distance from pos to the line.","title":"distanceToSq(pos: object, bounded: bool)"},{"location":"Linedef/#parameters_3","text":"pos: Point to check against bounded: true if only the finite length of the line should be used, false if the infinite length of the line should be used","title":"Parameters"},{"location":"Linedef/#return-value_2","text":"Squared distance to the line","title":"Return value"},{"location":"Linedef/#flip","text":"Flips the Linedef 's vertex attachments and Sidedef s. This is a shortcut to using both flipVertices() and flipSidedefs() .","title":"flip()"},{"location":"Linedef/#flipsidedefs","text":"Flips the Linedef 's Sidedef s.","title":"flipSidedefs()"},{"location":"Linedef/#flipvertices","text":"Flips the Linedef 's vertex attachments.","title":"flipVertices()"},{"location":"Linedef/#getcenterpoint","text":"Gets a Vector2D that's in the center of the Linedef .","title":"getCenterPoint()"},{"location":"Linedef/#return-value_3","text":"Vector2D in the center of the Linedef","title":"Return value"},{"location":"Linedef/#getsidepointfront-bool","text":"Gets a Vector2D for testing on one side. The Vector2D is on the front when true is passed, otherwise on the back.","title":"getSidePoint(front: bool)"},{"location":"Linedef/#parameters_4","text":"front: true for front, false for back","title":"Parameters"},{"location":"Linedef/#return-value_4","text":"Vector2D that's either on the front of back of the Linedef","title":"Return value"},{"location":"Linedef/#gettags","text":"Returns an Array of the Linedef 's tags. UDMF only. Supported game configurations only.","title":"getTags()"},{"location":"Linedef/#return-value_5","text":"Array of tags","title":"Return value"},{"location":"Linedef/#nearestonlinepos-object","text":"Get a Vector2D that's on the line, closest to pos . pos can either be a Vector2D , or an array of numbers. var v1 = ld.nearestOnLine(new Vector2D(32, 64)); var v2 = ld.nearestOnLine([ 32, 64 ]);","title":"nearestOnLine(pos: object)"},{"location":"Linedef/#parameters_5","text":"pos: Point to check against","title":"Parameters"},{"location":"Linedef/#return-value_6","text":"Vector2D that's on the linedef","title":"Return value"},{"location":"Linedef/#removetagtag-int","text":"Removes a tag from the Linedef . UDMF only. Supported game configurations only.","title":"removeTag(tag: int)"},{"location":"Linedef/#parameters_6","text":"tag: Tag to remove","title":"Parameters"},{"location":"Linedef/#return-value_7","text":"true when the tag was removed successfully, false when the tag did not exist","title":"Return value"},{"location":"Linedef/#safedistancetopos-object-bounded-bool","text":"Gets the shortest \"safe\" distance from pos to the line. If bounded is true that means that the not the whole line's length will be used, but lengthInv less at the start and end.","title":"safeDistanceTo(pos: object, bounded: bool)"},{"location":"Linedef/#parameters_7","text":"pos: Point to check against bounded: true if only the finite length of the line should be used, false if the infinite length of the line should be used","title":"Parameters"},{"location":"Linedef/#return-value_8","text":"Distance to the line","title":"Return value"},{"location":"Linedef/#safedistancetosqpos-object-bounded-bool","text":"Gets the shortest \"safe\" squared distance from pos to the line. If bounded is true that means that the not the whole line's length will be used, but lengthInv less at the start and end.","title":"safeDistanceToSq(pos: object, bounded: bool)"},{"location":"Linedef/#parameters_8","text":"pos: Point to check against bounded: true if only the finite length of the line should be used, false if the infinite length of the line should be used","title":"Parameters"},{"location":"Linedef/#return-value_9","text":"Squared distance to the line","title":"Return value"},{"location":"Linedef/#sideoflinepos-object","text":"Tests which side of the Linedef pos is on. Returns < 0 for front (right) side, > for back (left) side, and 0 if pos is on the line.","title":"sideOfLine(pos: object)"},{"location":"Linedef/#parameters_9","text":"pos: Point to check against","title":"Parameters"},{"location":"Linedef/#return-value_10","text":"< 0 for front (right) side, > for back (left) side, and 0 if pos is on the line","title":"Return value"},{"location":"Linedef/#splitpos-object","text":"Splits the Linedef at the given position. This can either be a Vector2D , an array of numbers, or an existing Vertex . The result will be two lines, from the start Vertex of the Linedef to pos , and from pos to the end Vertex of the Linedef .","title":"split(pos: object)"},{"location":"Linedef/#parameters_10","text":"pos: Vertex to split by","title":"Parameters"},{"location":"Linedef/#return-value_11","text":"The newly created Linedef","title":"Return value"},{"location":"Map/","text":"Map Properties camera VisualCamera object with information about the position of the camera in visual mode. Read-only. isDoom true if the map is in Doom format, false if it isn't. Read-only. isHexen true if the map is in Hexen format, false if it isn't. Read-only. isUDMF true if the map is in UDMF, false if it isn't. Read-only. mousePosition The map coordinates of the mouse position as a Vector2D . Read-only. Methods clearAllMarks(mark: bool) Sets the marked property of all map elements. Can be passed true to mark all map elements. Parameters mark: false to set the marked property to false (default), true to set the marked property to true clearAllSelected() Clears all selected map elements. clearMarkeLinedefs(mark: bool) Sets the marked property of all Linedef s. Can be passed true to mark all Linedef s. Parameters mark: false to set the marked property to false (default), true to set the marked property to true clearMarkeSectors(mark: bool) Sets the marked property of all Sector s. Can be passed true to mark all Sector s. Parameters mark: false to set the marked property to false (default), true to set the marked property to true clearMarkeSidedefs(mark: bool) Sets the marked property of all Sidedef s. Can be passed true to mark all Sidedef s. Parameters mark: false to set the marked property to false (default), true to set the marked property to true clearMarkedThings(mark: bool) Sets the marked property of all Thing s. Can be passed true to mark all Thing s. Parameters mark: false to set the marked property to false (default), true to set the marked property to true clearMarkedVertices(mark: bool) Sets the marked property of all vertices. Can be passed true to mark all vertices. Parameters mark: false to set the marked property to false (default), true to set the marked property to true clearSelectedSectors() Clears all selected Sector s. clearSelectedThings() Clears all selected Thing s. clearSelectedVertices() Clears all selected vertices. createThing(pos: object, type: int) Creates a new Thing at the given position. The position can be a Vector2D , Vector3D , or an Array of two numbers or three numbers (note that the z position only works for game configurations that support vertical pos. A thing type can be supplied optionally. var t1 = UDB.Map.createThing(new UDB.Vector2D(32, 64)); var t2 = UDB.Map.createThing([ 32, 64 ]); var t3 = UDB.Map.createThing(new UDB.Vector2D(32, 64), 3001); // Create an Imp var t4 = UDB.Map.createThing([ 32, 64 ], 3001); // Create an Imp Parameters pos: Position where the Thing should be created at type: Thing type (optional) Return value The new Thing createVertex(pos: object) Creates a new Vertex at the given position. The position can be a Vector2D or an Array of two numbers. var v1 = UDB.Map.createVertex(new Vector2D(32, 64)); var v2 = UDB.Map.createVertex([ 32, 64 ]); Parameters pos: Position where the Vertex should be created at Return value The created Vertex drawLines(data: object) Draws lines. Data has to be an Array of Array of numbers, Vector2D s, Vector3D s, or objects with x and y properties. Note that the first and last element have to be at the same positions to make a complete drawing. UDB.Map.drawLines([ new UDB.Vector2D(64, 0), new UDB.Vector2D(128, 0), new UDB.Vector2D(128, 64), new UDB.Vector2D(64, 64), new UDB.Vector2D(64, 0) ]); UDB.Map.drawLines([ [ 0, 0 ], [ 64, 0 ], [ 64, 64 ], [ 0, 64 ], [ 0, 0 ] ]); Parameters data: Array of positions Return value true if drawing was successful, false if it wasn't getHighlightedLinedef() Get the currently highlighted Linedef . Return value The currently highlighted Linedef or null if no Linedef is highlighted getHighlightedSector() Get the currently highlighted Sector . Return value The currently highlighted Sector or null if no Sector is highlighted getHighlightedThing() Get the currently highlighted Thing . Return value The currently highlighted Thing or null if no Thing is highlighted getHighlightedVertex() Get the currently highlighted Vertex . Return value The currently highlighted Vertex or null if no Vertex is highlighted getLinedefs() Returns an Array of all Linedef s in the map. Return value Array of Linedef s getMarkedLinedefs(mark: bool) Gets all marked (default) or unmarked Linedef s. Parameters mark: true to get all marked Linedef s (default), false to get all unmarked Linedef s Return value missing getMarkedSectors(mark: bool) Gets all marked (default) or unmarked Sector s. Parameters mark: true to get all marked Sector s (default), false to get all unmarked Sector s Return value missing getMarkedSidedefs(mark: bool) Gets all marked (default) or unmarked Sidedef s. Parameters mark: true to get all marked Sidedef s (default), false to get all unmarked Sidedef s Return value missing getMarkedThings(mark: bool) Gets all marked (default) or unmarked Thing s. Parameters mark: true to get all marked Thing s (default), false to get all unmarked Thing s Return value missing getMarkedVertices(mark: bool) Gets all marked (default) or unmarked vertices. Parameters mark: true to get all marked vertices (default), false to get all unmarked vertices Return value missing getMultipleNewTags(count: int) Gets multiple new tags. Parameters count: Number of tags to get Return value Array of the new tags getNewTag(usedtags: int[]) Gets a new tag. Parameters usedtags: Array of tags to skip Return value The new tag getSectors() Returns an Array of all Sector s in the map. Return value Array of Sector s getSelectedLinedefs(selected: bool) Gets all selected (default) or unselected Linedef s. Parameters selected: true to get all selected Linedef s, false to get all unselected ones Return value Array of Linedef s getSelectedOrHighlightedLinedefs() Gets the currently selected Linedef s or , if no Linede f s are selected, a currently highlighted Linedef`. Return value Array of Linedef s getSelectedOrHighlightedSectors() Gets the currently selected Sector s or , if no Sector s are selected, a currently highlighted Sector . Return value Array of Sector s getSelectedOrHighlightedThings() Gets the currently selected Thing s or , if no Thing s are selected, a currently highlighted Thing . Return value Array of Thing s getSelectedOrHighlightedVertices() Gets the currently selected Vertex s or , if no Vertex s are selected, a currently highlighted Vertex . Return value Array of Vertex getSelectedSectors(selected: bool) Gets all selected (default) or unselected Sector s. Parameters selected: true to get all selected Sector s, false to get all unselected ones Return value Array of Sector s getSelectedThings(selected: bool) Gets all selected (default) or unselected Thing s. Parameters selected: true to get all selected Thing s, false to get all unselected ones Return value Array of Thing s getSelectedVertices(selected: bool) Gets all selected (default) or unselected vertices. Parameters selected: true to get all selected vertices, false to get all unselected ones Return value Array of Vertex getSidedefs() Returns an Array of all Sidedef s in the map. Return value Array of Sidedef s getSidedefsFromSelectedLinedefs(selected: bool) Gets all Sidedef s from the selected Linedef s. In classic modes this will return both sidedefs of 2-sided lines, in visual mode it will only return the actually selected Sidedef . Parameters selected: true to get all Sidedef s of all selected Linedef s, false to get all Sidedef s of all unselected Linedef s Return value Array of Sidedef Version: 3 getSidedefsFromSelectedOrHighlightedLinedefs() Gets the Sidedef s of the currently selected Linedef s or , if no Linedef s are selected, the Sidedef s of the currently highlighted Linedef . In classic modes this will return both sidedefs of 2-sided lines, in visual mode it will only return the actually selected Sidedef . Return value Array of Sidedef s getThings() Returns an Array of all Thing s in the map. Return value Array of Thing s getVertices() Returns an Array of all Vertex in the map. Return value Array of Vertex invertAllMarks() Inverts all marks of all map elements. invertMarkedLinedefs() Inverts the marked property of all Linedef s. invertMarkedSectors() Inverts the marked property of all Sector s. invertMarkedSidedefs() Inverts the marked property of all Sidedef s. invertMarkedThings() Inverts the marked property of all Thing s. invertMarkedVertices() Inverts the marked property of all vertices. joinSectors(sectors: Sector[]) Joins Sector s, keeping lines shared by the Sector s. All Sector s will be joined with the first Sector in the array. Parameters sectors: Array of Sector s markSelectedLinedefs(mark: bool) Marks (default) or unmarks all selected Linedef s. Parameters mark: true to mark all selected Linedef s (default), false to unmark markSelectedSectors(mark: bool) Marks (default) or unmarks all selected Sector s. Parameters mark: true to mark all selected Sector s (default), false to unmark markSelectedThings(mark: bool) Marks (default) or unmarks all selected Thing s. Parameters mark: true to mark all selected Thing s (default), false to unmark markSelectedVertices(mark: bool) Marks (default) or unmarks all selected vertices. Parameters mark: true to mark all selected vertices (default), false to unmark mergeSectors(sectors: Sector[]) Merges Sector s, deleting lines shared by the Sector s. All Sector s will be merged into the first Sector in the array. Parameters sectors: Array of Sector s nearestLinedef(pos: object, maxrange: double) Gets the Linedef that's nearest to the specified position. Parameters pos: Position to check against maxrange: Maximum range (optional) Return value Nearest Linedef nearestSidedef(pos: object) Gets the Sidedef that's nearest to the specified position. Parameters pos: Position to check against maxrange: Maximum range (optional) Return value Nearest Sidedef nearestThing(pos: object, maxrange: double) Gets the Thing that's nearest to the specified position. Parameters pos: Position to check against maxrange: Maximum range (optional) Return value Nearest Linedef nearestVertex(pos: object, maxrange: double) Gets the Vertex that's nearest to the specified position. Parameters pos: Position to check against maxrange: Maximum range (optional) Return value Nearest Vertex snapAllToAccuracy(usepreciseposition: bool) Snaps all vertices and things to the map format accuracy. Call this to ensure the vertices and things are at valid coordinates. Parameters usepreciseposition: true if decimal places defined by the map format should be used, false if no decimal places should be used snappedToGrid(pos: object) Returns the given point snapped to the current grid. Parameters pos: Point that should be snapped to the grid Return value Snapped position as Vector2D stitchGeometry(mergemode: MergeGeometryMode) Stitches marked geometry with non-marked geometry. Parameters mergemode: Mode to merge by as MergeGeometryMode Return value true if successful, false if failed Enums Version: 5 MergeGeometryMode How geometry should be merged when geometry is stitched. UDB.Map.stitchGeometry(UDB.Map.MergeometryMode.MERGE); Options CLASSIC: Merge vertices only MERGE: Merge vertices and lines REPLACE: Merge vertices and lines, replacing sector geometry","title":"Map"},{"location":"Map/#map","text":"","title":"Map"},{"location":"Map/#properties","text":"","title":"Properties"},{"location":"Map/#camera","text":"VisualCamera object with information about the position of the camera in visual mode. Read-only.","title":"camera"},{"location":"Map/#isdoom","text":"true if the map is in Doom format, false if it isn't. Read-only.","title":"isDoom"},{"location":"Map/#ishexen","text":"true if the map is in Hexen format, false if it isn't. Read-only.","title":"isHexen"},{"location":"Map/#isudmf","text":"true if the map is in UDMF, false if it isn't. Read-only.","title":"isUDMF"},{"location":"Map/#mouseposition","text":"The map coordinates of the mouse position as a Vector2D . Read-only.","title":"mousePosition"},{"location":"Map/#methods","text":"","title":"Methods"},{"location":"Map/#clearallmarksmark-bool","text":"Sets the marked property of all map elements. Can be passed true to mark all map elements.","title":"clearAllMarks(mark: bool)"},{"location":"Map/#parameters","text":"mark: false to set the marked property to false (default), true to set the marked property to true","title":"Parameters"},{"location":"Map/#clearallselected","text":"Clears all selected map elements.","title":"clearAllSelected()"},{"location":"Map/#clearmarkelinedefsmark-bool","text":"Sets the marked property of all Linedef s. Can be passed true to mark all Linedef s.","title":"clearMarkeLinedefs(mark: bool)"},{"location":"Map/#parameters_1","text":"mark: false to set the marked property to false (default), true to set the marked property to true","title":"Parameters"},{"location":"Map/#clearmarkesectorsmark-bool","text":"Sets the marked property of all Sector s. Can be passed true to mark all Sector s.","title":"clearMarkeSectors(mark: bool)"},{"location":"Map/#parameters_2","text":"mark: false to set the marked property to false (default), true to set the marked property to true","title":"Parameters"},{"location":"Map/#clearmarkesidedefsmark-bool","text":"Sets the marked property of all Sidedef s. Can be passed true to mark all Sidedef s.","title":"clearMarkeSidedefs(mark: bool)"},{"location":"Map/#parameters_3","text":"mark: false to set the marked property to false (default), true to set the marked property to true","title":"Parameters"},{"location":"Map/#clearmarkedthingsmark-bool","text":"Sets the marked property of all Thing s. Can be passed true to mark all Thing s.","title":"clearMarkedThings(mark: bool)"},{"location":"Map/#parameters_4","text":"mark: false to set the marked property to false (default), true to set the marked property to true","title":"Parameters"},{"location":"Map/#clearmarkedverticesmark-bool","text":"Sets the marked property of all vertices. Can be passed true to mark all vertices.","title":"clearMarkedVertices(mark: bool)"},{"location":"Map/#parameters_5","text":"mark: false to set the marked property to false (default), true to set the marked property to true","title":"Parameters"},{"location":"Map/#clearselectedsectors","text":"Clears all selected Sector s.","title":"clearSelectedSectors()"},{"location":"Map/#clearselectedthings","text":"Clears all selected Thing s.","title":"clearSelectedThings()"},{"location":"Map/#clearselectedvertices","text":"Clears all selected vertices.","title":"clearSelectedVertices()"},{"location":"Map/#createthingpos-object-type-int","text":"Creates a new Thing at the given position. The position can be a Vector2D , Vector3D , or an Array of two numbers or three numbers (note that the z position only works for game configurations that support vertical pos. A thing type can be supplied optionally. var t1 = UDB.Map.createThing(new UDB.Vector2D(32, 64)); var t2 = UDB.Map.createThing([ 32, 64 ]); var t3 = UDB.Map.createThing(new UDB.Vector2D(32, 64), 3001); // Create an Imp var t4 = UDB.Map.createThing([ 32, 64 ], 3001); // Create an Imp","title":"createThing(pos: object, type: int)"},{"location":"Map/#parameters_6","text":"pos: Position where the Thing should be created at type: Thing type (optional)","title":"Parameters"},{"location":"Map/#return-value","text":"The new Thing","title":"Return value"},{"location":"Map/#createvertexpos-object","text":"Creates a new Vertex at the given position. The position can be a Vector2D or an Array of two numbers. var v1 = UDB.Map.createVertex(new Vector2D(32, 64)); var v2 = UDB.Map.createVertex([ 32, 64 ]);","title":"createVertex(pos: object)"},{"location":"Map/#parameters_7","text":"pos: Position where the Vertex should be created at","title":"Parameters"},{"location":"Map/#return-value_1","text":"The created Vertex","title":"Return value"},{"location":"Map/#drawlinesdata-object","text":"Draws lines. Data has to be an Array of Array of numbers, Vector2D s, Vector3D s, or objects with x and y properties. Note that the first and last element have to be at the same positions to make a complete drawing. UDB.Map.drawLines([ new UDB.Vector2D(64, 0), new UDB.Vector2D(128, 0), new UDB.Vector2D(128, 64), new UDB.Vector2D(64, 64), new UDB.Vector2D(64, 0) ]); UDB.Map.drawLines([ [ 0, 0 ], [ 64, 0 ], [ 64, 64 ], [ 0, 64 ], [ 0, 0 ] ]);","title":"drawLines(data: object)"},{"location":"Map/#parameters_8","text":"data: Array of positions","title":"Parameters"},{"location":"Map/#return-value_2","text":"true if drawing was successful, false if it wasn't","title":"Return value"},{"location":"Map/#gethighlightedlinedef","text":"Get the currently highlighted Linedef .","title":"getHighlightedLinedef()"},{"location":"Map/#return-value_3","text":"The currently highlighted Linedef or null if no Linedef is highlighted","title":"Return value"},{"location":"Map/#gethighlightedsector","text":"Get the currently highlighted Sector .","title":"getHighlightedSector()"},{"location":"Map/#return-value_4","text":"The currently highlighted Sector or null if no Sector is highlighted","title":"Return value"},{"location":"Map/#gethighlightedthing","text":"Get the currently highlighted Thing .","title":"getHighlightedThing()"},{"location":"Map/#return-value_5","text":"The currently highlighted Thing or null if no Thing is highlighted","title":"Return value"},{"location":"Map/#gethighlightedvertex","text":"Get the currently highlighted Vertex .","title":"getHighlightedVertex()"},{"location":"Map/#return-value_6","text":"The currently highlighted Vertex or null if no Vertex is highlighted","title":"Return value"},{"location":"Map/#getlinedefs","text":"Returns an Array of all Linedef s in the map.","title":"getLinedefs()"},{"location":"Map/#return-value_7","text":"Array of Linedef s","title":"Return value"},{"location":"Map/#getmarkedlinedefsmark-bool","text":"Gets all marked (default) or unmarked Linedef s.","title":"getMarkedLinedefs(mark: bool)"},{"location":"Map/#parameters_9","text":"mark: true to get all marked Linedef s (default), false to get all unmarked Linedef s","title":"Parameters"},{"location":"Map/#return-value_8","text":"missing","title":"Return value"},{"location":"Map/#getmarkedsectorsmark-bool","text":"Gets all marked (default) or unmarked Sector s.","title":"getMarkedSectors(mark: bool)"},{"location":"Map/#parameters_10","text":"mark: true to get all marked Sector s (default), false to get all unmarked Sector s","title":"Parameters"},{"location":"Map/#return-value_9","text":"missing","title":"Return value"},{"location":"Map/#getmarkedsidedefsmark-bool","text":"Gets all marked (default) or unmarked Sidedef s.","title":"getMarkedSidedefs(mark: bool)"},{"location":"Map/#parameters_11","text":"mark: true to get all marked Sidedef s (default), false to get all unmarked Sidedef s","title":"Parameters"},{"location":"Map/#return-value_10","text":"missing","title":"Return value"},{"location":"Map/#getmarkedthingsmark-bool","text":"Gets all marked (default) or unmarked Thing s.","title":"getMarkedThings(mark: bool)"},{"location":"Map/#parameters_12","text":"mark: true to get all marked Thing s (default), false to get all unmarked Thing s","title":"Parameters"},{"location":"Map/#return-value_11","text":"missing","title":"Return value"},{"location":"Map/#getmarkedverticesmark-bool","text":"Gets all marked (default) or unmarked vertices.","title":"getMarkedVertices(mark: bool)"},{"location":"Map/#parameters_13","text":"mark: true to get all marked vertices (default), false to get all unmarked vertices","title":"Parameters"},{"location":"Map/#return-value_12","text":"missing","title":"Return value"},{"location":"Map/#getmultiplenewtagscount-int","text":"Gets multiple new tags.","title":"getMultipleNewTags(count: int)"},{"location":"Map/#parameters_14","text":"count: Number of tags to get","title":"Parameters"},{"location":"Map/#return-value_13","text":"Array of the new tags","title":"Return value"},{"location":"Map/#getnewtagusedtags-int","text":"Gets a new tag.","title":"getNewTag(usedtags: int[])"},{"location":"Map/#parameters_15","text":"usedtags: Array of tags to skip","title":"Parameters"},{"location":"Map/#return-value_14","text":"The new tag","title":"Return value"},{"location":"Map/#getsectors","text":"Returns an Array of all Sector s in the map.","title":"getSectors()"},{"location":"Map/#return-value_15","text":"Array of Sector s","title":"Return value"},{"location":"Map/#getselectedlinedefsselected-bool","text":"Gets all selected (default) or unselected Linedef s.","title":"getSelectedLinedefs(selected: bool)"},{"location":"Map/#parameters_16","text":"selected: true to get all selected Linedef s, false to get all unselected ones","title":"Parameters"},{"location":"Map/#return-value_16","text":"Array of Linedef s","title":"Return value"},{"location":"Map/#getselectedorhighlightedlinedefs","text":"Gets the currently selected Linedef s or , if no Linede f s are selected, a currently highlighted Linedef`.","title":"getSelectedOrHighlightedLinedefs()"},{"location":"Map/#return-value_17","text":"Array of Linedef s","title":"Return value"},{"location":"Map/#getselectedorhighlightedsectors","text":"Gets the currently selected Sector s or , if no Sector s are selected, a currently highlighted Sector .","title":"getSelectedOrHighlightedSectors()"},{"location":"Map/#return-value_18","text":"Array of Sector s","title":"Return value"},{"location":"Map/#getselectedorhighlightedthings","text":"Gets the currently selected Thing s or , if no Thing s are selected, a currently highlighted Thing .","title":"getSelectedOrHighlightedThings()"},{"location":"Map/#return-value_19","text":"Array of Thing s","title":"Return value"},{"location":"Map/#getselectedorhighlightedvertices","text":"Gets the currently selected Vertex s or , if no Vertex s are selected, a currently highlighted Vertex .","title":"getSelectedOrHighlightedVertices()"},{"location":"Map/#return-value_20","text":"Array of Vertex","title":"Return value"},{"location":"Map/#getselectedsectorsselected-bool","text":"Gets all selected (default) or unselected Sector s.","title":"getSelectedSectors(selected: bool)"},{"location":"Map/#parameters_17","text":"selected: true to get all selected Sector s, false to get all unselected ones","title":"Parameters"},{"location":"Map/#return-value_21","text":"Array of Sector s","title":"Return value"},{"location":"Map/#getselectedthingsselected-bool","text":"Gets all selected (default) or unselected Thing s.","title":"getSelectedThings(selected: bool)"},{"location":"Map/#parameters_18","text":"selected: true to get all selected Thing s, false to get all unselected ones","title":"Parameters"},{"location":"Map/#return-value_22","text":"Array of Thing s","title":"Return value"},{"location":"Map/#getselectedverticesselected-bool","text":"Gets all selected (default) or unselected vertices.","title":"getSelectedVertices(selected: bool)"},{"location":"Map/#parameters_19","text":"selected: true to get all selected vertices, false to get all unselected ones","title":"Parameters"},{"location":"Map/#return-value_23","text":"Array of Vertex","title":"Return value"},{"location":"Map/#getsidedefs","text":"Returns an Array of all Sidedef s in the map.","title":"getSidedefs()"},{"location":"Map/#return-value_24","text":"Array of Sidedef s","title":"Return value"},{"location":"Map/#getsidedefsfromselectedlinedefsselected-bool","text":"Gets all Sidedef s from the selected Linedef s. In classic modes this will return both sidedefs of 2-sided lines, in visual mode it will only return the actually selected Sidedef .","title":"getSidedefsFromSelectedLinedefs(selected: bool)"},{"location":"Map/#parameters_20","text":"selected: true to get all Sidedef s of all selected Linedef s, false to get all Sidedef s of all unselected Linedef s","title":"Parameters"},{"location":"Map/#return-value_25","text":"Array of Sidedef Version: 3","title":"Return value"},{"location":"Map/#getsidedefsfromselectedorhighlightedlinedefs","text":"Gets the Sidedef s of the currently selected Linedef s or , if no Linedef s are selected, the Sidedef s of the currently highlighted Linedef . In classic modes this will return both sidedefs of 2-sided lines, in visual mode it will only return the actually selected Sidedef .","title":"getSidedefsFromSelectedOrHighlightedLinedefs()"},{"location":"Map/#return-value_26","text":"Array of Sidedef s","title":"Return value"},{"location":"Map/#getthings","text":"Returns an Array of all Thing s in the map.","title":"getThings()"},{"location":"Map/#return-value_27","text":"Array of Thing s","title":"Return value"},{"location":"Map/#getvertices","text":"Returns an Array of all Vertex in the map.","title":"getVertices()"},{"location":"Map/#return-value_28","text":"Array of Vertex","title":"Return value"},{"location":"Map/#invertallmarks","text":"Inverts all marks of all map elements.","title":"invertAllMarks()"},{"location":"Map/#invertmarkedlinedefs","text":"Inverts the marked property of all Linedef s.","title":"invertMarkedLinedefs()"},{"location":"Map/#invertmarkedsectors","text":"Inverts the marked property of all Sector s.","title":"invertMarkedSectors()"},{"location":"Map/#invertmarkedsidedefs","text":"Inverts the marked property of all Sidedef s.","title":"invertMarkedSidedefs()"},{"location":"Map/#invertmarkedthings","text":"Inverts the marked property of all Thing s.","title":"invertMarkedThings()"},{"location":"Map/#invertmarkedvertices","text":"Inverts the marked property of all vertices.","title":"invertMarkedVertices()"},{"location":"Map/#joinsectorssectors-sector","text":"Joins Sector s, keeping lines shared by the Sector s. All Sector s will be joined with the first Sector in the array.","title":"joinSectors(sectors: Sector[])"},{"location":"Map/#parameters_21","text":"sectors: Array of Sector s","title":"Parameters"},{"location":"Map/#markselectedlinedefsmark-bool","text":"Marks (default) or unmarks all selected Linedef s.","title":"markSelectedLinedefs(mark: bool)"},{"location":"Map/#parameters_22","text":"mark: true to mark all selected Linedef s (default), false to unmark","title":"Parameters"},{"location":"Map/#markselectedsectorsmark-bool","text":"Marks (default) or unmarks all selected Sector s.","title":"markSelectedSectors(mark: bool)"},{"location":"Map/#parameters_23","text":"mark: true to mark all selected Sector s (default), false to unmark","title":"Parameters"},{"location":"Map/#markselectedthingsmark-bool","text":"Marks (default) or unmarks all selected Thing s.","title":"markSelectedThings(mark: bool)"},{"location":"Map/#parameters_24","text":"mark: true to mark all selected Thing s (default), false to unmark","title":"Parameters"},{"location":"Map/#markselectedverticesmark-bool","text":"Marks (default) or unmarks all selected vertices.","title":"markSelectedVertices(mark: bool)"},{"location":"Map/#parameters_25","text":"mark: true to mark all selected vertices (default), false to unmark","title":"Parameters"},{"location":"Map/#mergesectorssectors-sector","text":"Merges Sector s, deleting lines shared by the Sector s. All Sector s will be merged into the first Sector in the array.","title":"mergeSectors(sectors: Sector[])"},{"location":"Map/#parameters_26","text":"sectors: Array of Sector s","title":"Parameters"},{"location":"Map/#nearestlinedefpos-object-maxrange-double","text":"Gets the Linedef that's nearest to the specified position.","title":"nearestLinedef(pos: object, maxrange: double)"},{"location":"Map/#parameters_27","text":"pos: Position to check against maxrange: Maximum range (optional)","title":"Parameters"},{"location":"Map/#return-value_29","text":"Nearest Linedef","title":"Return value"},{"location":"Map/#nearestsidedefpos-object","text":"Gets the Sidedef that's nearest to the specified position.","title":"nearestSidedef(pos: object)"},{"location":"Map/#parameters_28","text":"pos: Position to check against maxrange: Maximum range (optional)","title":"Parameters"},{"location":"Map/#return-value_30","text":"Nearest Sidedef","title":"Return value"},{"location":"Map/#nearestthingpos-object-maxrange-double","text":"Gets the Thing that's nearest to the specified position.","title":"nearestThing(pos: object, maxrange: double)"},{"location":"Map/#parameters_29","text":"pos: Position to check against maxrange: Maximum range (optional)","title":"Parameters"},{"location":"Map/#return-value_31","text":"Nearest Linedef","title":"Return value"},{"location":"Map/#nearestvertexpos-object-maxrange-double","text":"Gets the Vertex that's nearest to the specified position.","title":"nearestVertex(pos: object, maxrange: double)"},{"location":"Map/#parameters_30","text":"pos: Position to check against maxrange: Maximum range (optional)","title":"Parameters"},{"location":"Map/#return-value_32","text":"Nearest Vertex","title":"Return value"},{"location":"Map/#snapalltoaccuracyusepreciseposition-bool","text":"Snaps all vertices and things to the map format accuracy. Call this to ensure the vertices and things are at valid coordinates.","title":"snapAllToAccuracy(usepreciseposition: bool)"},{"location":"Map/#parameters_31","text":"usepreciseposition: true if decimal places defined by the map format should be used, false if no decimal places should be used","title":"Parameters"},{"location":"Map/#snappedtogridpos-object","text":"Returns the given point snapped to the current grid.","title":"snappedToGrid(pos: object)"},{"location":"Map/#parameters_32","text":"pos: Point that should be snapped to the grid","title":"Parameters"},{"location":"Map/#return-value_33","text":"Snapped position as Vector2D","title":"Return value"},{"location":"Map/#stitchgeometrymergemode-mergegeometrymode","text":"Stitches marked geometry with non-marked geometry.","title":"stitchGeometry(mergemode: MergeGeometryMode)"},{"location":"Map/#parameters_33","text":"mergemode: Mode to merge by as MergeGeometryMode","title":"Parameters"},{"location":"Map/#return-value_34","text":"true if successful, false if failed","title":"Return value"},{"location":"Map/#enums","text":"Version: 5","title":"Enums"},{"location":"Map/#mergegeometrymode","text":"How geometry should be merged when geometry is stitched. UDB.Map.stitchGeometry(UDB.Map.MergeometryMode.MERGE);","title":"MergeGeometryMode"},{"location":"Map/#options","text":"CLASSIC: Merge vertices only MERGE: Merge vertices and lines REPLACE: Merge vertices and lines, replacing sector geometry","title":"Options"},{"location":"Pen/","text":"Pen The Pen class is an built-in library. It can be used to to create geometry Turtle graphics style. The class is inspired of the Pen class in Doom Builder X. Example: // Draw a regular pentagon let p = new Pen([ 0, 0 ]); for(let i=0; i < 5; i++) { p.drawVertex(); p.moveForward(128); p.turnRight(72); } p.finishDrawing(); Example with method chaining (new in version 2): // Draw a regular pentagon let p = new Pen([ 0, 0 ]); for(let i=0; i < 5; i++) p.drawVertex().moveForward(128).turnRight(72); p.finishDrawing(); Constructors Pen(pos=new Vector2D(0.0, 0.0)) Creates an instance of the Pen class. The position can be a Vector2D or an Array of two numbers. Parameters pos: start position of the pen (optional) Return value An instance of the Pen class Methods moveForward(distance) Moves the pen by a distance at the current angle. Parameters distance: number of units to move Return value The instance of the Pen class (new in version 2) moveTo(pos) Moves the pen to the given position. The position can be a Vector2D or an Array of two numbers. Parameters pos: position to move the pen to Return value The instance of the Pen class (new in version 2) setAngle(degrees) Sets the angle to the given degrees. Parameters degrees: degrees to set the angle to Return value The instance of the Pen class (new in version 2) setAngleRadians(radians) Sets the angle to the given radians. Parameters radians: radians to set the angle to Return value The instance of the Pen class (new in version 2) turnLeft(degrees=90.0) Turns the pen left by the given degrees. Parameters degrees: degrees to turn left by. If omitted it will turn by 90\u00b0 Return value The instance of the Pen class (new in version 2) turnLeftRadians(radians=Math.PI/2) Turns the pen left by the given radians. Parameters radians: radians to turn left by. If omitted it will turn by Pi/2 Return value The instance of the Pen class (new in version 2) turnRight(degrees=90.0) Turns the pen right by the given degrees. Parameters degrees: degrees to turn right by. If omitted it will turn by 90\u00b0 Return value The instance of the Pen class (new in version 2) turnRightRadians(radians=Math.PI/2) Turns the pen right by the given radians. Parameters radians: radians to turn right by. If omitted it will turn by Pi/2 Return value The instance of the Pen class (new in version 2) drawVertex() Draws a Vertex at the current position. Return value The instance of the Pen class (new in version 2) finishDrawing(close=false) Finishes the drawing, actually creating the geometry. Also resets the vertices of this instance of Pen . Parameters close: if the drawing should be automatically close (going back to the first vertex) or not","title":"Pen"},{"location":"Pen/#pen","text":"The Pen class is an built-in library. It can be used to to create geometry Turtle graphics style. The class is inspired of the Pen class in Doom Builder X. Example: // Draw a regular pentagon let p = new Pen([ 0, 0 ]); for(let i=0; i < 5; i++) { p.drawVertex(); p.moveForward(128); p.turnRight(72); } p.finishDrawing(); Example with method chaining (new in version 2): // Draw a regular pentagon let p = new Pen([ 0, 0 ]); for(let i=0; i < 5; i++) p.drawVertex().moveForward(128).turnRight(72); p.finishDrawing();","title":"Pen"},{"location":"Pen/#constructors","text":"","title":"Constructors"},{"location":"Pen/#penposnew-vector2d00-00","text":"Creates an instance of the Pen class. The position can be a Vector2D or an Array of two numbers.","title":"Pen(pos=new Vector2D(0.0, 0.0))"},{"location":"Pen/#parameters","text":"pos: start position of the pen (optional)","title":"Parameters"},{"location":"Pen/#return-value","text":"An instance of the Pen class","title":"Return value"},{"location":"Pen/#methods","text":"","title":"Methods"},{"location":"Pen/#moveforwarddistance","text":"Moves the pen by a distance at the current angle.","title":"moveForward(distance)"},{"location":"Pen/#parameters_1","text":"distance: number of units to move","title":"Parameters"},{"location":"Pen/#return-value_1","text":"The instance of the Pen class (new in version 2)","title":"Return value"},{"location":"Pen/#movetopos","text":"Moves the pen to the given position. The position can be a Vector2D or an Array of two numbers.","title":"moveTo(pos)"},{"location":"Pen/#parameters_2","text":"pos: position to move the pen to","title":"Parameters"},{"location":"Pen/#return-value_2","text":"The instance of the Pen class (new in version 2)","title":"Return value"},{"location":"Pen/#setangledegrees","text":"Sets the angle to the given degrees.","title":"setAngle(degrees)"},{"location":"Pen/#parameters_3","text":"degrees: degrees to set the angle to","title":"Parameters"},{"location":"Pen/#return-value_3","text":"The instance of the Pen class (new in version 2)","title":"Return value"},{"location":"Pen/#setangleradiansradians","text":"Sets the angle to the given radians.","title":"setAngleRadians(radians)"},{"location":"Pen/#parameters_4","text":"radians: radians to set the angle to","title":"Parameters"},{"location":"Pen/#return-value_4","text":"The instance of the Pen class (new in version 2)","title":"Return value"},{"location":"Pen/#turnleftdegrees900","text":"Turns the pen left by the given degrees.","title":"turnLeft(degrees=90.0)"},{"location":"Pen/#parameters_5","text":"degrees: degrees to turn left by. If omitted it will turn by 90\u00b0","title":"Parameters"},{"location":"Pen/#return-value_5","text":"The instance of the Pen class (new in version 2)","title":"Return value"},{"location":"Pen/#turnleftradiansradiansmathpi2","text":"Turns the pen left by the given radians.","title":"turnLeftRadians(radians=Math.PI/2)"},{"location":"Pen/#parameters_6","text":"radians: radians to turn left by. If omitted it will turn by Pi/2","title":"Parameters"},{"location":"Pen/#return-value_6","text":"The instance of the Pen class (new in version 2)","title":"Return value"},{"location":"Pen/#turnrightdegrees900","text":"Turns the pen right by the given degrees.","title":"turnRight(degrees=90.0)"},{"location":"Pen/#parameters_7","text":"degrees: degrees to turn right by. If omitted it will turn by 90\u00b0","title":"Parameters"},{"location":"Pen/#return-value_7","text":"The instance of the Pen class (new in version 2)","title":"Return value"},{"location":"Pen/#turnrightradiansradiansmathpi2","text":"Turns the pen right by the given radians.","title":"turnRightRadians(radians=Math.PI/2)"},{"location":"Pen/#parameters_8","text":"radians: radians to turn right by. If omitted it will turn by Pi/2","title":"Parameters"},{"location":"Pen/#return-value_8","text":"The instance of the Pen class (new in version 2)","title":"Return value"},{"location":"Pen/#drawvertex","text":"Draws a Vertex at the current position.","title":"drawVertex()"},{"location":"Pen/#return-value_9","text":"The instance of the Pen class (new in version 2)","title":"Return value"},{"location":"Pen/#finishdrawingclosefalse","text":"Finishes the drawing, actually creating the geometry. Also resets the vertices of this instance of Pen .","title":"finishDrawing(close=false)"},{"location":"Pen/#parameters_9","text":"close: if the drawing should be automatically close (going back to the first vertex) or not","title":"Parameters"},{"location":"Plane/","text":"Plane Constructors Version: 5 Plane(normal: object, offset: double) Creates a new Plane from a normal and an offset. The normal vector has to be Vector3D , Array s of 3 numbers, or an object with x, y, and z properties. let plane1 = new UDB.Plane(new Vector3D(0.0, -0.707, 0.707), 32); let plane2 = new UDB.Plane([ 0.0, -0.707, 0.707 ], 32); Parameters normal: Normal vector of the plane offset: Distance of the plane from the origin Version: 5 Plane(p1: object, p2: object, p3: object, up: bool) Creates a new Plane from 3 points. The points have to be Vector3D , Array s of 3 numbers, or an object with x, y, and z properties. let plane1 = new UDB.Plane(new Vector3D(0, 0, 0), new Vector3D(64, 0, 0), new Vector3D(64, 64, 32), true); let plane2 = new UDB.Plane([ 0, 0, 0 ], [ 64, 0, 0 ], [ 64, 64, 32 ], true); Parameters p1: First point p2: Second point p3: Thrid point up: true if plane is pointing up, false if pointing down Properties Version: 5 a The a value of the plane equation. This is the x value of the normal vector. Version: 5 b The b value of the plane equation. This is the y value of the normal vector. Version: 5 c The c value of the plane equation. This is the z value of the normal vector. Version: 5 d The d value of the plane equation. This is the same as the offset value. Version: 5 normal The plane's normal vector. Version: 5 offset The distance of the plane along the normal vector. Methods Version: 5 closestOnPlane(p: object) Returns the point that's closest to the given point on the Plane . The given point can be a Vector3D or an Array of three numbers. const plane = new UDB.Plane([ 0, 0, 0 ], [ 32, 0, 0 ], [ 32, 32, 16 ], true); UDB.log(plane.closestOnPlane([ 16, 16, 32 ])); // Prints '16, 25.6, 12.8' Parameters p: Point to get the closest position from Return value Point as Vector3D on the plane closest to the given point Version: 5 distance(p: object) Computes the distance between the Plane and a point. The given point can be a Vector3D or an Array of three numbers. A result greater than 0 means the point is on the front of the plane, less than 0 means the point is behind the plane. const plane = new UDB.Plane([ 0, 0, 0 ], [ 32, 0, 0 ], [ 32, 32, 16 ], true); UDB.log(plane.distance([ 16, 16, 32 ])); // Prints '21.466252583998' Parameters p: Point to compute the distnace to Return value Distance between the Plane and the point as number Version: 5 getIntersection(from: object, to: object) Checks if the line between from and to intersects the plane. It returns an Array , where the first element is a bool vaue indicating if there is an intersector, and the second element is the position of the intersection on the line between the two points. const plane = new UDB.Plane([ 0, 0, 1 ], 0); const [intersecting, u] = plane.getIntersection([0, 0, 32], [0, 0, -32]); UDB.log(`${intersecting} / ${u}`); // Prints \"true / 0.5\" Parameters from: Vector3D of the start of the line to: Vector3D of the end of the line Return value missing Version: 5 getZ(p: object) Returns the position on the z axis of the plane for the given point. The given point can be a Vector2D or an Array of two numbers. const plane = new UDB.Plane([ 0, 0, 0 ], [ 32, 0, 0 ], [ 32, 32, 16 ], true); UDB.log(plane.getZ([ 16, 16 ])); // Prints '8' Parameters p: Point to get the z position from Return value missing","title":"Plane"},{"location":"Plane/#plane","text":"","title":"Plane"},{"location":"Plane/#constructors","text":"Version: 5","title":"Constructors"},{"location":"Plane/#planenormal-object-offset-double","text":"Creates a new Plane from a normal and an offset. The normal vector has to be Vector3D , Array s of 3 numbers, or an object with x, y, and z properties. let plane1 = new UDB.Plane(new Vector3D(0.0, -0.707, 0.707), 32); let plane2 = new UDB.Plane([ 0.0, -0.707, 0.707 ], 32);","title":"Plane(normal: object, offset: double)"},{"location":"Plane/#parameters","text":"normal: Normal vector of the plane offset: Distance of the plane from the origin Version: 5","title":"Parameters"},{"location":"Plane/#planep1-object-p2-object-p3-object-up-bool","text":"Creates a new Plane from 3 points. The points have to be Vector3D , Array s of 3 numbers, or an object with x, y, and z properties. let plane1 = new UDB.Plane(new Vector3D(0, 0, 0), new Vector3D(64, 0, 0), new Vector3D(64, 64, 32), true); let plane2 = new UDB.Plane([ 0, 0, 0 ], [ 64, 0, 0 ], [ 64, 64, 32 ], true);","title":"Plane(p1: object, p2: object, p3: object, up: bool)"},{"location":"Plane/#parameters_1","text":"p1: First point p2: Second point p3: Thrid point up: true if plane is pointing up, false if pointing down","title":"Parameters"},{"location":"Plane/#properties","text":"Version: 5","title":"Properties"},{"location":"Plane/#a","text":"The a value of the plane equation. This is the x value of the normal vector. Version: 5","title":"a"},{"location":"Plane/#b","text":"The b value of the plane equation. This is the y value of the normal vector. Version: 5","title":"b"},{"location":"Plane/#c","text":"The c value of the plane equation. This is the z value of the normal vector. Version: 5","title":"c"},{"location":"Plane/#d","text":"The d value of the plane equation. This is the same as the offset value. Version: 5","title":"d"},{"location":"Plane/#normal","text":"The plane's normal vector. Version: 5","title":"normal"},{"location":"Plane/#offset","text":"The distance of the plane along the normal vector.","title":"offset"},{"location":"Plane/#methods","text":"Version: 5","title":"Methods"},{"location":"Plane/#closestonplanep-object","text":"Returns the point that's closest to the given point on the Plane . The given point can be a Vector3D or an Array of three numbers. const plane = new UDB.Plane([ 0, 0, 0 ], [ 32, 0, 0 ], [ 32, 32, 16 ], true); UDB.log(plane.closestOnPlane([ 16, 16, 32 ])); // Prints '16, 25.6, 12.8'","title":"closestOnPlane(p: object)"},{"location":"Plane/#parameters_2","text":"p: Point to get the closest position from","title":"Parameters"},{"location":"Plane/#return-value","text":"Point as Vector3D on the plane closest to the given point Version: 5","title":"Return value"},{"location":"Plane/#distancep-object","text":"Computes the distance between the Plane and a point. The given point can be a Vector3D or an Array of three numbers. A result greater than 0 means the point is on the front of the plane, less than 0 means the point is behind the plane. const plane = new UDB.Plane([ 0, 0, 0 ], [ 32, 0, 0 ], [ 32, 32, 16 ], true); UDB.log(plane.distance([ 16, 16, 32 ])); // Prints '21.466252583998'","title":"distance(p: object)"},{"location":"Plane/#parameters_3","text":"p: Point to compute the distnace to","title":"Parameters"},{"location":"Plane/#return-value_1","text":"Distance between the Plane and the point as number Version: 5","title":"Return value"},{"location":"Plane/#getintersectionfrom-object-to-object","text":"Checks if the line between from and to intersects the plane. It returns an Array , where the first element is a bool vaue indicating if there is an intersector, and the second element is the position of the intersection on the line between the two points. const plane = new UDB.Plane([ 0, 0, 1 ], 0); const [intersecting, u] = plane.getIntersection([0, 0, 32], [0, 0, -32]); UDB.log(`${intersecting} / ${u}`); // Prints \"true / 0.5\"","title":"getIntersection(from: object, to: object)"},{"location":"Plane/#parameters_4","text":"from: Vector3D of the start of the line to: Vector3D of the end of the line","title":"Parameters"},{"location":"Plane/#return-value_2","text":"missing Version: 5","title":"Return value"},{"location":"Plane/#getzp-object","text":"Returns the position on the z axis of the plane for the given point. The given point can be a Vector2D or an Array of two numbers. const plane = new UDB.Plane([ 0, 0, 0 ], [ 32, 0, 0 ], [ 32, 32, 16 ], true); UDB.log(plane.getZ([ 16, 16 ])); // Prints '8'","title":"getZ(p: object)"},{"location":"Plane/#parameters_5","text":"p: Point to get the z position from","title":"Parameters"},{"location":"Plane/#return-value_3","text":"missing","title":"Return value"},{"location":"QueryOptions/","text":"QueryOptions The QueryOptions class is used to query the user for their input. It effectively works the same as specifying script options in the script's metadata, except that the QueryOptions class works at run-time. Example: let qo = new QueryOptions(); qo.addOption('length', 'Length of the sides', 0, 128); qo.addOption('numsides', 'Number of sides', 0, 5); qo.addOption('direction', 'Direction to go', 11, 1, { 1: 'Up', 2: 'Down' }); // Enumeration qo.query(); showMessage('You want ' + qo.options.numsides + ' sides with a length of ' + qo.options.length); Constructors QueryOptions() Initializes a new QueryOptions object. Properties options Object containing all the added options as properties. Methods addOption(name: string, description: string, type: int, defaultvalue: object) Adds a parameter to query Parameters name: Name of the variable that the queried value is stored in description: Textual description of the parameter type: UniversalType value of the parameter defaultvalue: Default value of the parameter addOption(name: string, description: string, type: int, defaultvalue: object, enumvalues: object) Adds a parameter to query Parameters name: Name of the variable that the queried value is stored in description: Textual description of the parameter type: UniversalType value of the parameter defaultvalue: Default value of the parameter clear() Removes all parameters query() Queries all parameters. Options a window where the user can enter values for the options added through addOption() . Return value True if OK was pressed, otherwise false","title":"QueryOptions"},{"location":"QueryOptions/#queryoptions","text":"The QueryOptions class is used to query the user for their input. It effectively works the same as specifying script options in the script's metadata, except that the QueryOptions class works at run-time. Example: let qo = new QueryOptions(); qo.addOption('length', 'Length of the sides', 0, 128); qo.addOption('numsides', 'Number of sides', 0, 5); qo.addOption('direction', 'Direction to go', 11, 1, { 1: 'Up', 2: 'Down' }); // Enumeration qo.query(); showMessage('You want ' + qo.options.numsides + ' sides with a length of ' + qo.options.length);","title":"QueryOptions"},{"location":"QueryOptions/#constructors","text":"","title":"Constructors"},{"location":"QueryOptions/#queryoptions_1","text":"Initializes a new QueryOptions object.","title":"QueryOptions()"},{"location":"QueryOptions/#properties","text":"","title":"Properties"},{"location":"QueryOptions/#options","text":"Object containing all the added options as properties.","title":"options"},{"location":"QueryOptions/#methods","text":"","title":"Methods"},{"location":"QueryOptions/#addoptionname-string-description-string-type-int-defaultvalue-object","text":"Adds a parameter to query","title":"addOption(name: string, description: string, type: int, defaultvalue: object)"},{"location":"QueryOptions/#parameters","text":"name: Name of the variable that the queried value is stored in description: Textual description of the parameter type: UniversalType value of the parameter defaultvalue: Default value of the parameter","title":"Parameters"},{"location":"QueryOptions/#addoptionname-string-description-string-type-int-defaultvalue-object-enumvalues-object","text":"Adds a parameter to query","title":"addOption(name: string, description: string, type: int, defaultvalue: object, enumvalues: object)"},{"location":"QueryOptions/#parameters_1","text":"name: Name of the variable that the queried value is stored in description: Textual description of the parameter type: UniversalType value of the parameter defaultvalue: Default value of the parameter","title":"Parameters"},{"location":"QueryOptions/#clear","text":"Removes all parameters","title":"clear()"},{"location":"QueryOptions/#query","text":"Queries all parameters. Options a window where the user can enter values for the options added through addOption() .","title":"query()"},{"location":"QueryOptions/#return-value","text":"True if OK was pressed, otherwise false","title":"Return value"},{"location":"Sector/","text":"Sector Properties brightness The Sector 's brightness. ceilingHeight Ceiling height of the Sector . Version: 3 ceilingHighlighted If the Sector 's ceiling is highlighted or not. Will always return true in classic modes if the Sector is highlighted. Read-only. Version: 3 ceilingSelected If the Sector 's ceiling is selected or not. Will always return true in classic modes if the Sector is selected. Read-only. ceilingSlopeOffset The ceiling's slope offset. ceilingTexture Ceiling texture of the Sector . fields UDMF fields. It's an object with the fields as properties. s.fields.comment = 'This is a comment'; s.fields['comment'] = 'This is a comment'; // Also works s.fields.xscalefloor = 2.0; t.fields.score = 100; It is also possible to define new fields: s.fields.user_myboolfield = true; There are some restrictions, though: it only works for fields that are not in the base UDMF standard, since those are handled directly in the respective class it does not work for flags. While they are technically also UDMF fields, they are handled in the flags field of the respective class (where applicable) JavaScript does not distinguish between integer and floating point numbers, it only has floating point numbers (of double precision). For fields where UDB knows that they are integers this it not a problem, since it'll automatically convert the floating point numbers to integers (dropping the fractional part). However, if you need to specify an integer value for an unknown or custom field you have to work around this limitation: Version 5 and later: You can use a BigInt . This is done by appending a n to the number. Note that this is just a convenient way to define whole numbers, it still only supports 32 bit integers: s.fields.user_myintfield = 25n; // Sets the 'user_myintfield' field to an integer value of 25 In version 4 and earlier you have to use the UniValue class: s.fields.user_myintfield = new UDB.UniValue(0, 25); // Sets the 'user_myintfield' field to an integer value of 25 To remove a field you have to assign null to it: s.fields.user_myintfield = null; flags Sector flags. It's an object with the flags as properties. Only available in UDMF. s.flags['noattack'] = true; // Monsters in this sector don't attack s.flags.noattack = true; // Also works floorHeight Floor height of the Sector . Version: 3 floorHighlighted If the Sector 's floor is highlighted or not. Will always return true in classic modes if the Sector is highlighted. Read-only. Version: 3 floorSelected If the Sector 's floor is selected or not. Will always return true in classic modes if the Sector is selected. Read-only. floorSlopeOffset The floor's slope offset. floorTexture Floor texture of the Sector . index The Sector 's index. Read-only. marked If the Sector is marked or not. It is used to mark map elements that were created or changed (for example after drawing new geometry). selected If the Sector is selected or not. special The Sector 's special type. tag The Sector 's tag. Methods addTag(tag: int) Adds a tag to the Sector . UDMF only. Supported game configurations only. Parameters tag: Tag to add Return value true when the tag was added, false when the tag already exists clearFlags() Clears all flags. copyPropertiesTo(s: Sector) Copies the properties from this Sector to another. Parameters s: the Sector to copy the properties to delete() Deletes the Sector and its Sidedef s. getCeilingSlope() Gets the ceiling's slope vector. Return value The ceiling's slope normal as a Vector3D getFloorSlope() Gets the floor's slope vector. Return value The floor's slope normal as a Vector3D Version: 5 Version: 5 getLabelPositions() Returns an Array of Vector2D of label positions for the Sector . This are the positions where for example selection number or tags are shown. This example adds an imp to the label position of each sector in the map: UDB.Map.getSectors().forEach(s => { const positions = s.getLabelPositions(); if(positions.length > 0) UDB.Map.createThing(positions[0], 3001); }); Return value Array of Vector2D of all label positions getSidedefs() Returns an Array of all Sidedef s of the Sector . Return value Array of the Sector 's Sidedef s getTags() Returns an Array of the Sector 's tags. UDMF only. Supported game configurations only. Return value Array of tags getTriangles() Gets an array of Vector2D arrays, representing the vertices of the triangulated sector. Note that for sectors with islands some triangles may not always have their points on existing vertices. Return value Array of Vector2D arrays intersect(p: object) Checks if the given point is in this Sector or not. The given point can be a Vector2D or an Array of two numbers. if(s.intersect(new Vector2D(32, 64))) UDB.showMessage('Point is in the sector!'); if(s.intersect([ 32, 64 ])) UDB.showMessage('Point is in the sector!'); Parameters p: Point to test Return value true if the point is in the Sector , false if it isn't join(other: Sector) Joins this Sector with another Sector . Lines shared between the sectors will not be removed. Parameters other: Sector to join with removeTag(tag: int) Removes a tag from the Sector . UDMF only. Supported game configurations only. Parameters tag: Tag to remove Return value true when the tag was removed successfully, false when the tag did not exist setCeilingSlope(normal: object) Sets the ceiling's slope vector. The vector has to be normalized. Parameters normal: The new slope vector as Vector3D setFloorSlope(normal: object) Sets the floor's slope vector. The vector has to be normalized. Parameters normal: The new slope vector as Vector3D","title":"Sector"},{"location":"Sector/#sector","text":"","title":"Sector"},{"location":"Sector/#properties","text":"","title":"Properties"},{"location":"Sector/#brightness","text":"The Sector 's brightness.","title":"brightness"},{"location":"Sector/#ceilingheight","text":"Ceiling height of the Sector . Version: 3","title":"ceilingHeight"},{"location":"Sector/#ceilinghighlighted","text":"If the Sector 's ceiling is highlighted or not. Will always return true in classic modes if the Sector is highlighted. Read-only. Version: 3","title":"ceilingHighlighted"},{"location":"Sector/#ceilingselected","text":"If the Sector 's ceiling is selected or not. Will always return true in classic modes if the Sector is selected. Read-only.","title":"ceilingSelected"},{"location":"Sector/#ceilingslopeoffset","text":"The ceiling's slope offset.","title":"ceilingSlopeOffset"},{"location":"Sector/#ceilingtexture","text":"Ceiling texture of the Sector .","title":"ceilingTexture"},{"location":"Sector/#fields","text":"UDMF fields. It's an object with the fields as properties. s.fields.comment = 'This is a comment'; s.fields['comment'] = 'This is a comment'; // Also works s.fields.xscalefloor = 2.0; t.fields.score = 100; It is also possible to define new fields: s.fields.user_myboolfield = true; There are some restrictions, though: it only works for fields that are not in the base UDMF standard, since those are handled directly in the respective class it does not work for flags. While they are technically also UDMF fields, they are handled in the flags field of the respective class (where applicable) JavaScript does not distinguish between integer and floating point numbers, it only has floating point numbers (of double precision). For fields where UDB knows that they are integers this it not a problem, since it'll automatically convert the floating point numbers to integers (dropping the fractional part). However, if you need to specify an integer value for an unknown or custom field you have to work around this limitation: Version 5 and later: You can use a BigInt . This is done by appending a n to the number. Note that this is just a convenient way to define whole numbers, it still only supports 32 bit integers: s.fields.user_myintfield = 25n; // Sets the 'user_myintfield' field to an integer value of 25 In version 4 and earlier you have to use the UniValue class: s.fields.user_myintfield = new UDB.UniValue(0, 25); // Sets the 'user_myintfield' field to an integer value of 25 To remove a field you have to assign null to it: s.fields.user_myintfield = null;","title":"fields"},{"location":"Sector/#flags","text":"Sector flags. It's an object with the flags as properties. Only available in UDMF. s.flags['noattack'] = true; // Monsters in this sector don't attack s.flags.noattack = true; // Also works","title":"flags"},{"location":"Sector/#floorheight","text":"Floor height of the Sector . Version: 3","title":"floorHeight"},{"location":"Sector/#floorhighlighted","text":"If the Sector 's floor is highlighted or not. Will always return true in classic modes if the Sector is highlighted. Read-only. Version: 3","title":"floorHighlighted"},{"location":"Sector/#floorselected","text":"If the Sector 's floor is selected or not. Will always return true in classic modes if the Sector is selected. Read-only.","title":"floorSelected"},{"location":"Sector/#floorslopeoffset","text":"The floor's slope offset.","title":"floorSlopeOffset"},{"location":"Sector/#floortexture","text":"Floor texture of the Sector .","title":"floorTexture"},{"location":"Sector/#index","text":"The Sector 's index. Read-only.","title":"index"},{"location":"Sector/#marked","text":"If the Sector is marked or not. It is used to mark map elements that were created or changed (for example after drawing new geometry).","title":"marked"},{"location":"Sector/#selected","text":"If the Sector is selected or not.","title":"selected"},{"location":"Sector/#special","text":"The Sector 's special type.","title":"special"},{"location":"Sector/#tag","text":"The Sector 's tag.","title":"tag"},{"location":"Sector/#methods","text":"","title":"Methods"},{"location":"Sector/#addtagtag-int","text":"Adds a tag to the Sector . UDMF only. Supported game configurations only.","title":"addTag(tag: int)"},{"location":"Sector/#parameters","text":"tag: Tag to add","title":"Parameters"},{"location":"Sector/#return-value","text":"true when the tag was added, false when the tag already exists","title":"Return value"},{"location":"Sector/#clearflags","text":"Clears all flags.","title":"clearFlags()"},{"location":"Sector/#copypropertiestos-sector","text":"Copies the properties from this Sector to another.","title":"copyPropertiesTo(s: Sector)"},{"location":"Sector/#parameters_1","text":"s: the Sector to copy the properties to","title":"Parameters"},{"location":"Sector/#delete","text":"Deletes the Sector and its Sidedef s.","title":"delete()"},{"location":"Sector/#getceilingslope","text":"Gets the ceiling's slope vector.","title":"getCeilingSlope()"},{"location":"Sector/#return-value_1","text":"The ceiling's slope normal as a Vector3D","title":"Return value"},{"location":"Sector/#getfloorslope","text":"Gets the floor's slope vector.","title":"getFloorSlope()"},{"location":"Sector/#return-value_2","text":"The floor's slope normal as a Vector3D Version: 5 Version: 5","title":"Return value"},{"location":"Sector/#getlabelpositions","text":"Returns an Array of Vector2D of label positions for the Sector . This are the positions where for example selection number or tags are shown. This example adds an imp to the label position of each sector in the map: UDB.Map.getSectors().forEach(s => { const positions = s.getLabelPositions(); if(positions.length > 0) UDB.Map.createThing(positions[0], 3001); });","title":"getLabelPositions()"},{"location":"Sector/#return-value_3","text":"Array of Vector2D of all label positions","title":"Return value"},{"location":"Sector/#getsidedefs","text":"Returns an Array of all Sidedef s of the Sector .","title":"getSidedefs()"},{"location":"Sector/#return-value_4","text":"Array of the Sector 's Sidedef s","title":"Return value"},{"location":"Sector/#gettags","text":"Returns an Array of the Sector 's tags. UDMF only. Supported game configurations only.","title":"getTags()"},{"location":"Sector/#return-value_5","text":"Array of tags","title":"Return value"},{"location":"Sector/#gettriangles","text":"Gets an array of Vector2D arrays, representing the vertices of the triangulated sector. Note that for sectors with islands some triangles may not always have their points on existing vertices.","title":"getTriangles()"},{"location":"Sector/#return-value_6","text":"Array of Vector2D arrays","title":"Return value"},{"location":"Sector/#intersectp-object","text":"Checks if the given point is in this Sector or not. The given point can be a Vector2D or an Array of two numbers. if(s.intersect(new Vector2D(32, 64))) UDB.showMessage('Point is in the sector!'); if(s.intersect([ 32, 64 ])) UDB.showMessage('Point is in the sector!');","title":"intersect(p: object)"},{"location":"Sector/#parameters_2","text":"p: Point to test","title":"Parameters"},{"location":"Sector/#return-value_7","text":"true if the point is in the Sector , false if it isn't","title":"Return value"},{"location":"Sector/#joinother-sector","text":"Joins this Sector with another Sector . Lines shared between the sectors will not be removed.","title":"join(other: Sector)"},{"location":"Sector/#parameters_3","text":"other: Sector to join with","title":"Parameters"},{"location":"Sector/#removetagtag-int","text":"Removes a tag from the Sector . UDMF only. Supported game configurations only.","title":"removeTag(tag: int)"},{"location":"Sector/#parameters_4","text":"tag: Tag to remove","title":"Parameters"},{"location":"Sector/#return-value_8","text":"true when the tag was removed successfully, false when the tag did not exist","title":"Return value"},{"location":"Sector/#setceilingslopenormal-object","text":"Sets the ceiling's slope vector. The vector has to be normalized.","title":"setCeilingSlope(normal: object)"},{"location":"Sector/#parameters_5","text":"normal: The new slope vector as Vector3D","title":"Parameters"},{"location":"Sector/#setfloorslopenormal-object","text":"Sets the floor's slope vector. The vector has to be normalized.","title":"setFloorSlope(normal: object)"},{"location":"Sector/#parameters_6","text":"normal: The new slope vector as Vector3D","title":"Parameters"},{"location":"Sidedef/","text":"Sidedef Properties angle The Sidedef 's angle in degrees. Read-only. angleRad The Sidedef 's angle in radians. Read-only. fields UDMF fields. It's an object with the fields as properties. s.fields.comment = 'This is a comment'; s.fields['comment'] = 'This is a comment'; // Also works s.fields.xscalefloor = 2.0; t.fields.score = 100; It is also possible to define new fields: s.fields.user_myboolfield = true; There are some restrictions, though: it only works for fields that are not in the base UDMF standard, since those are handled directly in the respective class it does not work for flags. While they are technically also UDMF fields, they are handled in the flags field of the respective class (where applicable) JavaScript does not distinguish between integer and floating point numbers, it only has floating point numbers (of double precision). For fields where UDB knows that they are integers this it not a problem, since it'll automatically convert the floating point numbers to integers (dropping the fractional part). However, if you need to specify an integer value for an unknown or custom field you have to work around this limitation: Version 5 and later: You can use a BigInt . This is done by appending a n to the number. Note that this is just a convenient way to define whole numbers, it still only supports 32 bit integers: s.fields.user_myintfield = 25n; // Sets the 'user_myintfield' field to an integer value of 25 In version 4 and earlier you have to use the UniValue class: s.fields.user_myintfield = new UDB.UniValue(0, 25); // Sets the 'user_myintfield' field to an integer value of 25 To remove a field you have to assign null to it: s.fields.user_myintfield = null; flags Sidedef flags. It's an object with the flags as properties. Only available in UDMF. s.flags['noattack'] = true; // Monsters in this sector don't attack s.flags.noattack = true; // Also works index The Sidedef 's index. Read-only. isFront true if this Sidedef is the front of its Linedef , otherwise false . Read-only. line The Linedef the Sidedef belongs to. Read-only. Version: 3 lowerHighlighted If the Sidedef 's lower part is highlighted or not. Will always return true in classic modes if the parent Linedef is selected. Version: 3 lowerSelected If the Sidedef 's lower part is selected or not. Will always return true in classic modes if the parent Linedef is selected. lowerTexture The Sidedef 's lower texture. Version: 3 middleHighlighted If the Sidedef 's middle part is highlighted or not. Will always return true in classic modes if the parent Linedef is selected. Version: 3 middleSelected If the Sidedef 's middle part is selected or not. Will always return true in classic modes if the parent Linedef is selected. middleTexture The Sidedef 's middle texture. offsetX The x offset of the Sidedef 's textures. offsetY The y offset of the Sidedef 's textures. other The Sidedef on the other side of this Sidedef 's Linedef . Returns null if there is no other. Read-only. sector The Sector the Sidedef belongs to. Read-only. Version: 3 upperHighlighted If the Sidedef 's upper part is highlighted or not. Will always return true in classic modes if the parent Linedef is selected. Version: 3 upperSelected If the Sidedef 's upper part is selected or not. Will always return true in classic modes if the parent Linedef is selected. upperTexture The Sidedef 's upper texture.","title":"Sidedef"},{"location":"Sidedef/#sidedef","text":"","title":"Sidedef"},{"location":"Sidedef/#properties","text":"","title":"Properties"},{"location":"Sidedef/#angle","text":"The Sidedef 's angle in degrees. Read-only.","title":"angle"},{"location":"Sidedef/#anglerad","text":"The Sidedef 's angle in radians. Read-only.","title":"angleRad"},{"location":"Sidedef/#fields","text":"UDMF fields. It's an object with the fields as properties. s.fields.comment = 'This is a comment'; s.fields['comment'] = 'This is a comment'; // Also works s.fields.xscalefloor = 2.0; t.fields.score = 100; It is also possible to define new fields: s.fields.user_myboolfield = true; There are some restrictions, though: it only works for fields that are not in the base UDMF standard, since those are handled directly in the respective class it does not work for flags. While they are technically also UDMF fields, they are handled in the flags field of the respective class (where applicable) JavaScript does not distinguish between integer and floating point numbers, it only has floating point numbers (of double precision). For fields where UDB knows that they are integers this it not a problem, since it'll automatically convert the floating point numbers to integers (dropping the fractional part). However, if you need to specify an integer value for an unknown or custom field you have to work around this limitation: Version 5 and later: You can use a BigInt . This is done by appending a n to the number. Note that this is just a convenient way to define whole numbers, it still only supports 32 bit integers: s.fields.user_myintfield = 25n; // Sets the 'user_myintfield' field to an integer value of 25 In version 4 and earlier you have to use the UniValue class: s.fields.user_myintfield = new UDB.UniValue(0, 25); // Sets the 'user_myintfield' field to an integer value of 25 To remove a field you have to assign null to it: s.fields.user_myintfield = null;","title":"fields"},{"location":"Sidedef/#flags","text":"Sidedef flags. It's an object with the flags as properties. Only available in UDMF. s.flags['noattack'] = true; // Monsters in this sector don't attack s.flags.noattack = true; // Also works","title":"flags"},{"location":"Sidedef/#index","text":"The Sidedef 's index. Read-only.","title":"index"},{"location":"Sidedef/#isfront","text":"true if this Sidedef is the front of its Linedef , otherwise false . Read-only.","title":"isFront"},{"location":"Sidedef/#line","text":"The Linedef the Sidedef belongs to. Read-only. Version: 3","title":"line"},{"location":"Sidedef/#lowerhighlighted","text":"If the Sidedef 's lower part is highlighted or not. Will always return true in classic modes if the parent Linedef is selected. Version: 3","title":"lowerHighlighted"},{"location":"Sidedef/#lowerselected","text":"If the Sidedef 's lower part is selected or not. Will always return true in classic modes if the parent Linedef is selected.","title":"lowerSelected"},{"location":"Sidedef/#lowertexture","text":"The Sidedef 's lower texture. Version: 3","title":"lowerTexture"},{"location":"Sidedef/#middlehighlighted","text":"If the Sidedef 's middle part is highlighted or not. Will always return true in classic modes if the parent Linedef is selected. Version: 3","title":"middleHighlighted"},{"location":"Sidedef/#middleselected","text":"If the Sidedef 's middle part is selected or not. Will always return true in classic modes if the parent Linedef is selected.","title":"middleSelected"},{"location":"Sidedef/#middletexture","text":"The Sidedef 's middle texture.","title":"middleTexture"},{"location":"Sidedef/#offsetx","text":"The x offset of the Sidedef 's textures.","title":"offsetX"},{"location":"Sidedef/#offsety","text":"The y offset of the Sidedef 's textures.","title":"offsetY"},{"location":"Sidedef/#other","text":"The Sidedef on the other side of this Sidedef 's Linedef . Returns null if there is no other. Read-only.","title":"other"},{"location":"Sidedef/#sector","text":"The Sector the Sidedef belongs to. Read-only. Version: 3","title":"sector"},{"location":"Sidedef/#upperhighlighted","text":"If the Sidedef 's upper part is highlighted or not. Will always return true in classic modes if the parent Linedef is selected. Version: 3","title":"upperHighlighted"},{"location":"Sidedef/#upperselected","text":"If the Sidedef 's upper part is selected or not. Will always return true in classic modes if the parent Linedef is selected.","title":"upperSelected"},{"location":"Sidedef/#uppertexture","text":"The Sidedef 's upper texture.","title":"upperTexture"},{"location":"Thing/","text":"Thing Properties action Thing action. Hexen and UDMF only. angle Angle of the Thing in degrees, see https://doomwiki.org/wiki/Angle. angleRad Angle of the Thing in radians. args Array of arguments of the Thing . Number of arguments depends on game config (usually 5). Hexen format and UDMF only. fields UDMF fields. It's an object with the fields as properties. s.fields.comment = 'This is a comment'; s.fields['comment'] = 'This is a comment'; // Also works s.fields.xscalefloor = 2.0; t.fields.score = 100; It is also possible to define new fields: s.fields.user_myboolfield = true; There are some restrictions, though: it only works for fields that are not in the base UDMF standard, since those are handled directly in the respective class it does not work for flags. While they are technically also UDMF fields, they are handled in the flags field of the respective class (where applicable) JavaScript does not distinguish between integer and floating point numbers, it only has floating point numbers (of double precision). For fields where UDB knows that they are integers this it not a problem, since it'll automatically convert the floating point numbers to integers (dropping the fractional part). However, if you need to specify an integer value for an unknown or custom field you have to work around this limitation: Version 5 and later: You can use a BigInt . This is done by appending a n to the number. Note that this is just a convenient way to define whole numbers, it still only supports 32 bit integers: s.fields.user_myintfield = 25n; // Sets the 'user_myintfield' field to an integer value of 25 In version 4 and earlier you have to use the UniValue class: s.fields.user_myintfield = new UDB.UniValue(0, 25); // Sets the 'user_myintfield' field to an integer value of 25 To remove a field you have to assign null to it: s.fields.user_myintfield = null; flags Thing flags. It's an object with the flags as properties. In Doom format and Hexen format they are identified by numbers, in UDMF by their name. Doom and Hexen: t.flags[\"8\"] = true; // Set the ambush flag UDMF: t.flags['ambush'] = true; // Set the ambush flag t.flags.ambush = true; // Also works index Index of the Thing . Read-only. marked If the Thing is marked or not. It is used to mark map elements that were created or changed (for example after drawing new geometry). pitch Pitch of the Thing in degrees. Only valid for supporting game configurations. position Position of the Thing . It's an object with x , y , and z properties. The latter is only relevant in Hexen format and UDMF. The x , y , and z accept numbers: t.position.x = 32; t.position.y = 64; It's also possible to set all fields immediately by assigning either a Vector2D , Vector3D , or an array of numbers: t.position = new UDB.Vector2D(32, 64); t.position = new UDB.Vector3D(32, 64, 128); t.position = [ 32, 64 ]; t.position = [ 32, 64, 128 ]; roll Roll of the Thing in degrees. Only valid for supporting game configurations. selected If the Thing is selected or not. tag Thing tag. UDMF only. type Type of the Thing . Methods clearFlags() Clears all flags. copyPropertiesTo(t: Thing) Copies the properties from this Thing to another. Parameters t: The Thing to copy the properties to delete() Deletes the Thing . distanceTo(pos: object) Gets the distance between this Thing and the given point. The point can be either a Vector2D or an array of numbers. t.distanceToSq(new UDB.Vector2D(32, 64)); t.distanceToSq([ 32, 64 ]); Parameters pos: Point to calculate the distance to. Return value Distance to pos distanceToSq(pos: object) Gets the squared distance between this Thing and the given point. The point can be either a Vector2D or an array of numbers. t.distanceToSq(new UDB.Vector2D(32, 64)); t.distanceToSq([ 32, 64 ]); Parameters pos: Point to calculate the squared distance to. Return value Distance to pos getSector() Determines and returns the Sector the Thing is in. Return value The Sector the Thing is in snapToAccuracy() Snaps the Thing 's position to the map format's accuracy. snapToGrid() Snaps the Thing 's position to the grid.","title":"Thing"},{"location":"Thing/#thing","text":"","title":"Thing"},{"location":"Thing/#properties","text":"","title":"Properties"},{"location":"Thing/#action","text":"Thing action. Hexen and UDMF only.","title":"action"},{"location":"Thing/#angle","text":"Angle of the Thing in degrees, see https://doomwiki.org/wiki/Angle.","title":"angle"},{"location":"Thing/#anglerad","text":"Angle of the Thing in radians.","title":"angleRad"},{"location":"Thing/#args","text":"Array of arguments of the Thing . Number of arguments depends on game config (usually 5). Hexen format and UDMF only.","title":"args"},{"location":"Thing/#fields","text":"UDMF fields. It's an object with the fields as properties. s.fields.comment = 'This is a comment'; s.fields['comment'] = 'This is a comment'; // Also works s.fields.xscalefloor = 2.0; t.fields.score = 100; It is also possible to define new fields: s.fields.user_myboolfield = true; There are some restrictions, though: it only works for fields that are not in the base UDMF standard, since those are handled directly in the respective class it does not work for flags. While they are technically also UDMF fields, they are handled in the flags field of the respective class (where applicable) JavaScript does not distinguish between integer and floating point numbers, it only has floating point numbers (of double precision). For fields where UDB knows that they are integers this it not a problem, since it'll automatically convert the floating point numbers to integers (dropping the fractional part). However, if you need to specify an integer value for an unknown or custom field you have to work around this limitation: Version 5 and later: You can use a BigInt . This is done by appending a n to the number. Note that this is just a convenient way to define whole numbers, it still only supports 32 bit integers: s.fields.user_myintfield = 25n; // Sets the 'user_myintfield' field to an integer value of 25 In version 4 and earlier you have to use the UniValue class: s.fields.user_myintfield = new UDB.UniValue(0, 25); // Sets the 'user_myintfield' field to an integer value of 25 To remove a field you have to assign null to it: s.fields.user_myintfield = null;","title":"fields"},{"location":"Thing/#flags","text":"Thing flags. It's an object with the flags as properties. In Doom format and Hexen format they are identified by numbers, in UDMF by their name. Doom and Hexen: t.flags[\"8\"] = true; // Set the ambush flag UDMF: t.flags['ambush'] = true; // Set the ambush flag t.flags.ambush = true; // Also works","title":"flags"},{"location":"Thing/#index","text":"Index of the Thing . Read-only.","title":"index"},{"location":"Thing/#marked","text":"If the Thing is marked or not. It is used to mark map elements that were created or changed (for example after drawing new geometry).","title":"marked"},{"location":"Thing/#pitch","text":"Pitch of the Thing in degrees. Only valid for supporting game configurations.","title":"pitch"},{"location":"Thing/#position","text":"Position of the Thing . It's an object with x , y , and z properties. The latter is only relevant in Hexen format and UDMF. The x , y , and z accept numbers: t.position.x = 32; t.position.y = 64; It's also possible to set all fields immediately by assigning either a Vector2D , Vector3D , or an array of numbers: t.position = new UDB.Vector2D(32, 64); t.position = new UDB.Vector3D(32, 64, 128); t.position = [ 32, 64 ]; t.position = [ 32, 64, 128 ];","title":"position"},{"location":"Thing/#roll","text":"Roll of the Thing in degrees. Only valid for supporting game configurations.","title":"roll"},{"location":"Thing/#selected","text":"If the Thing is selected or not.","title":"selected"},{"location":"Thing/#tag","text":"Thing tag. UDMF only.","title":"tag"},{"location":"Thing/#type","text":"Type of the Thing .","title":"type"},{"location":"Thing/#methods","text":"","title":"Methods"},{"location":"Thing/#clearflags","text":"Clears all flags.","title":"clearFlags()"},{"location":"Thing/#copypropertiestot-thing","text":"Copies the properties from this Thing to another.","title":"copyPropertiesTo(t: Thing)"},{"location":"Thing/#parameters","text":"t: The Thing to copy the properties to","title":"Parameters"},{"location":"Thing/#delete","text":"Deletes the Thing .","title":"delete()"},{"location":"Thing/#distancetopos-object","text":"Gets the distance between this Thing and the given point. The point can be either a Vector2D or an array of numbers. t.distanceToSq(new UDB.Vector2D(32, 64)); t.distanceToSq([ 32, 64 ]);","title":"distanceTo(pos: object)"},{"location":"Thing/#parameters_1","text":"pos: Point to calculate the distance to.","title":"Parameters"},{"location":"Thing/#return-value","text":"Distance to pos","title":"Return value"},{"location":"Thing/#distancetosqpos-object","text":"Gets the squared distance between this Thing and the given point. The point can be either a Vector2D or an array of numbers. t.distanceToSq(new UDB.Vector2D(32, 64)); t.distanceToSq([ 32, 64 ]);","title":"distanceToSq(pos: object)"},{"location":"Thing/#parameters_2","text":"pos: Point to calculate the squared distance to.","title":"Parameters"},{"location":"Thing/#return-value_1","text":"Distance to pos","title":"Return value"},{"location":"Thing/#getsector","text":"Determines and returns the Sector the Thing is in.","title":"getSector()"},{"location":"Thing/#return-value_2","text":"The Sector the Thing is in","title":"Return value"},{"location":"Thing/#snaptoaccuracy","text":"Snaps the Thing 's position to the map format's accuracy.","title":"snapToAccuracy()"},{"location":"Thing/#snaptogrid","text":"Snaps the Thing 's position to the grid.","title":"snapToGrid()"},{"location":"UDB/","text":"UDB Properties Angle2D Class containing methods related to angles. See Angle2D for more information. let rad = UDB.Angle2D.degToRad(46); Version: 5 BlockMap Instantiable class that contains methods related to blockmaps. See [BlockMap][BlockMap.md) for more information. Data Class containing methods related to the game data. See Data for more information. let hasfireblu = UDB.Data.textureExists('FIREBLU1'); GameConfiguration Class containing methods related to the game configuration. See GameConfiguration for more information. Line2D Instantiable class that contains methods related to two-dimensional lines. See Line2D for more information. let line = new UDB.Line2D([ 32, 64 ], [ 96, 128 ]); Map Object containing methods related to the map. See Map for more information. let sectors = UDB.Map.getSelectedOrHighlightedSectors(); Version: 5 Plane Instantiable class that contains methods related to a three-dimensional Plane. See Plane for more information. QueryOptions Class containing methods and properties related to querying options from the user at runtime. See QueryOptions for more information. ScriptOptions Object containing the script options. See Setting script options . UniValue The UniValue class. Is only needed when trying to assign integer values to UDMF fields. s.fields.user_myintfield = new UDB.UniValue(0, 25); Vector2D Instantiable class that contains methods related to two-dimensional vectors. See Vector2D for more information. let v = new UDB.Vector2D(32, 64); Vector3D Instantiable class that contains methods related to three-dimensional vectors. See Vector3D for more information. let v = new UDB.Vector3D(32, 64, 128); Methods die(s: string) Exist the script prematurely with undoing its changes. Parameters s: Text to show in the status bar (optional) exit(s: string) Exist the script prematurely without undoing its changes. Parameters s: Text to show in the status bar (optional) log(text: object) Adds a line to the script log. Also shows the script running dialog. Parameters text: Line to add to the script log setProgress(value: int) Set the progress of the script in percent. Value can be between 0 and 100. Also shows the script running dialog. Parameters value: Number between 0 and 100 showMessage(message: object) Shows a message box with an \"OK\" button. Parameters message: Message to show showMessageYesNo(message: object) Shows a message box with an \"Yes\" and \"No\" button. Parameters message: Message to show Return value true if \"Yes\" was clicked, false if \"No\" was clicked","title":"UDB"},{"location":"UDB/#udb","text":"","title":"UDB"},{"location":"UDB/#properties","text":"","title":"Properties"},{"location":"UDB/#angle2d","text":"Class containing methods related to angles. See Angle2D for more information. let rad = UDB.Angle2D.degToRad(46); Version: 5","title":"Angle2D"},{"location":"UDB/#blockmap","text":"Instantiable class that contains methods related to blockmaps. See [BlockMap][BlockMap.md) for more information.","title":"BlockMap"},{"location":"UDB/#data","text":"Class containing methods related to the game data. See Data for more information. let hasfireblu = UDB.Data.textureExists('FIREBLU1');","title":"Data"},{"location":"UDB/#gameconfiguration","text":"Class containing methods related to the game configuration. See GameConfiguration for more information.","title":"GameConfiguration"},{"location":"UDB/#line2d","text":"Instantiable class that contains methods related to two-dimensional lines. See Line2D for more information. let line = new UDB.Line2D([ 32, 64 ], [ 96, 128 ]);","title":"Line2D"},{"location":"UDB/#map","text":"Object containing methods related to the map. See Map for more information. let sectors = UDB.Map.getSelectedOrHighlightedSectors(); Version: 5","title":"Map"},{"location":"UDB/#plane","text":"Instantiable class that contains methods related to a three-dimensional Plane. See Plane for more information.","title":"Plane"},{"location":"UDB/#queryoptions","text":"Class containing methods and properties related to querying options from the user at runtime. See QueryOptions for more information.","title":"QueryOptions"},{"location":"UDB/#scriptoptions","text":"Object containing the script options. See Setting script options .","title":"ScriptOptions"},{"location":"UDB/#univalue","text":"The UniValue class. Is only needed when trying to assign integer values to UDMF fields. s.fields.user_myintfield = new UDB.UniValue(0, 25);","title":"UniValue"},{"location":"UDB/#vector2d","text":"Instantiable class that contains methods related to two-dimensional vectors. See Vector2D for more information. let v = new UDB.Vector2D(32, 64);","title":"Vector2D"},{"location":"UDB/#vector3d","text":"Instantiable class that contains methods related to three-dimensional vectors. See Vector3D for more information. let v = new UDB.Vector3D(32, 64, 128);","title":"Vector3D"},{"location":"UDB/#methods","text":"","title":"Methods"},{"location":"UDB/#dies-string","text":"Exist the script prematurely with undoing its changes.","title":"die(s: string)"},{"location":"UDB/#parameters","text":"s: Text to show in the status bar (optional)","title":"Parameters"},{"location":"UDB/#exits-string","text":"Exist the script prematurely without undoing its changes.","title":"exit(s: string)"},{"location":"UDB/#parameters_1","text":"s: Text to show in the status bar (optional)","title":"Parameters"},{"location":"UDB/#logtext-object","text":"Adds a line to the script log. Also shows the script running dialog.","title":"log(text: object)"},{"location":"UDB/#parameters_2","text":"text: Line to add to the script log","title":"Parameters"},{"location":"UDB/#setprogressvalue-int","text":"Set the progress of the script in percent. Value can be between 0 and 100. Also shows the script running dialog.","title":"setProgress(value: int)"},{"location":"UDB/#parameters_3","text":"value: Number between 0 and 100","title":"Parameters"},{"location":"UDB/#showmessagemessage-object","text":"Shows a message box with an \"OK\" button.","title":"showMessage(message: object)"},{"location":"UDB/#parameters_4","text":"message: Message to show","title":"Parameters"},{"location":"UDB/#showmessageyesnomessage-object","text":"Shows a message box with an \"Yes\" and \"No\" button.","title":"showMessageYesNo(message: object)"},{"location":"UDB/#parameters_5","text":"message: Message to show","title":"Parameters"},{"location":"UDB/#return-value","text":"true if \"Yes\" was clicked, false if \"No\" was clicked","title":"Return value"},{"location":"Vector2D/","text":"Vector2D Constructors Vector2D(x: double, y: double) Creates a new Vector2D from x and y coordinates let v = new UDB.Vector2D(32, 64); Parameters x: The x coordinate y: The y coordinate Vector2D(v: object) Creates a new Vector2D from a point. let v = new UDB.Vector2D([ 32, 64 ]); Parameters v: The vector to create the Vector2D from Static methods crossProduct(a: object, b: object) Returns the cross product of two Vector2D s. Parameters a: First Vector2D b: Second Vector2D Return value Cross product of the two vectors as Vector2D dotProduct(a: Vector2D, b: Vector2D) Returns the dot product of two Vector2D s. Parameters a: First Vector2D b: Second Vector2D Return value The dot product of the two vectors fromAngle(angle: double) Creates a Vector2D from an angle in degrees, Parameters angle: Angle in degrees Return value Vector as Vector2D fromAngleRad(angle: double) Creates a Vector2D from an angle in radians, Parameters angle: Angle in radians Return value Vector as Vector2D getAngle(a: object, b: object) Returns the angle between two Vector2D s in degrees. Parameters a: First Vector2D b: Second Vector2D Return value Angle in degrees getAngleRad(a: object, b: object) Returns the angle between two Vector2D s in radians Parameters a: First Vector2D b: Second Vector2D Return value Angle in radians getDistance(a: object, b: object) Returns the distance between two Vector2D s. Parameters a: First Vector2D b: Second Vector2D Return value The distance getDistanceSq(a: object, b: object) Returns the square distance between two Vector2D s. Parameters a: First Vector2D b: Second Vector2D Return value The squared distance reflect(v: object, m: object) Reflects a Vector2D over a mirror Vector2D . Parameters v: Vector2D to reflect m: Mirror Vector2D Return value The reflected vector as Vector2D reversed(v: object) Returns a reversed Vector2D . Parameters v: Vector2D to reverse Return value The reversed vector as Vector2D Properties x The x value of the vector. y The y value of the vector. Methods getAngle() Returns the angle of the Vector2D in degree. Return value The angle of the Vector2D in degree getAngleRad() Returns the angle of the Vector2D in radians. Return value The angle of the Vector2D in radians getInverseTransformed(invoffsetx: double, invoffsety: double, invscalex: double, invscaley: double) Returns the inverse transformed vector as Vector2D . Parameters invoffsetx: X offset invoffsety: Y offset invscalex: X scale invscaley: Y scale Return value The inverse transformed vector as Vector2D getLength() Returns the length of the Vector2D . Return value The length of the Vector2D getLengthSq() Returns the square length of the Vector2D . Return value The square length of the Vector2D getNormal() Returns the normal of the Vector2D . Return value The normal as Vector2D getPerpendicular() Returns the perpendicular to the Vector2D . Return value The perpendicular as Vector2D getRotated(theta: double) Returns the rotated vector as Vector2D . Parameters theta: Angle in degree to rotate by Return value The rotated Vector2D getRotatedRad(theta: double) Returns the rotated vector as Vector2D . Parameters theta: Angle in radians to rotate by Return value The rotated Vector2D getSign() Returns a Vector2D with the sign of all components. Return value A Vector2D with the sign of all components getTransformed(offsetx: double, offsety: double, scalex: double, scaley: double) Returns the transformed vector as Vector2D . Parameters offsetx: X offset offsety: Y offset scalex: X scale scaley: Y scale Return value The transformed vector as Vector2D isFinite() Checks if the Vector2D is finite or not. Return value true if Vector2D is finite, otherwise false","title":"Vector2D"},{"location":"Vector2D/#vector2d","text":"","title":"Vector2D"},{"location":"Vector2D/#constructors","text":"","title":"Constructors"},{"location":"Vector2D/#vector2dx-double-y-double","text":"Creates a new Vector2D from x and y coordinates let v = new UDB.Vector2D(32, 64);","title":"Vector2D(x: double, y: double)"},{"location":"Vector2D/#parameters","text":"x: The x coordinate y: The y coordinate","title":"Parameters"},{"location":"Vector2D/#vector2dv-object","text":"Creates a new Vector2D from a point. let v = new UDB.Vector2D([ 32, 64 ]);","title":"Vector2D(v: object)"},{"location":"Vector2D/#parameters_1","text":"v: The vector to create the Vector2D from","title":"Parameters"},{"location":"Vector2D/#static-methods","text":"","title":"Static methods"},{"location":"Vector2D/#crossproducta-object-b-object","text":"Returns the cross product of two Vector2D s.","title":"crossProduct(a: object, b: object)"},{"location":"Vector2D/#parameters_2","text":"a: First Vector2D b: Second Vector2D","title":"Parameters"},{"location":"Vector2D/#return-value","text":"Cross product of the two vectors as Vector2D","title":"Return value"},{"location":"Vector2D/#dotproducta-vector2d-b-vector2d","text":"Returns the dot product of two Vector2D s.","title":"dotProduct(a: Vector2D, b: Vector2D)"},{"location":"Vector2D/#parameters_3","text":"a: First Vector2D b: Second Vector2D","title":"Parameters"},{"location":"Vector2D/#return-value_1","text":"The dot product of the two vectors","title":"Return value"},{"location":"Vector2D/#fromangleangle-double","text":"Creates a Vector2D from an angle in degrees,","title":"fromAngle(angle: double)"},{"location":"Vector2D/#parameters_4","text":"angle: Angle in degrees","title":"Parameters"},{"location":"Vector2D/#return-value_2","text":"Vector as Vector2D","title":"Return value"},{"location":"Vector2D/#fromangleradangle-double","text":"Creates a Vector2D from an angle in radians,","title":"fromAngleRad(angle: double)"},{"location":"Vector2D/#parameters_5","text":"angle: Angle in radians","title":"Parameters"},{"location":"Vector2D/#return-value_3","text":"Vector as Vector2D","title":"Return value"},{"location":"Vector2D/#getanglea-object-b-object","text":"Returns the angle between two Vector2D s in degrees.","title":"getAngle(a: object, b: object)"},{"location":"Vector2D/#parameters_6","text":"a: First Vector2D b: Second Vector2D","title":"Parameters"},{"location":"Vector2D/#return-value_4","text":"Angle in degrees","title":"Return value"},{"location":"Vector2D/#getanglerada-object-b-object","text":"Returns the angle between two Vector2D s in radians","title":"getAngleRad(a: object, b: object)"},{"location":"Vector2D/#parameters_7","text":"a: First Vector2D b: Second Vector2D","title":"Parameters"},{"location":"Vector2D/#return-value_5","text":"Angle in radians","title":"Return value"},{"location":"Vector2D/#getdistancea-object-b-object","text":"Returns the distance between two Vector2D s.","title":"getDistance(a: object, b: object)"},{"location":"Vector2D/#parameters_8","text":"a: First Vector2D b: Second Vector2D","title":"Parameters"},{"location":"Vector2D/#return-value_6","text":"The distance","title":"Return value"},{"location":"Vector2D/#getdistancesqa-object-b-object","text":"Returns the square distance between two Vector2D s.","title":"getDistanceSq(a: object, b: object)"},{"location":"Vector2D/#parameters_9","text":"a: First Vector2D b: Second Vector2D","title":"Parameters"},{"location":"Vector2D/#return-value_7","text":"The squared distance","title":"Return value"},{"location":"Vector2D/#reflectv-object-m-object","text":"Reflects a Vector2D over a mirror Vector2D .","title":"reflect(v: object, m: object)"},{"location":"Vector2D/#parameters_10","text":"v: Vector2D to reflect m: Mirror Vector2D","title":"Parameters"},{"location":"Vector2D/#return-value_8","text":"The reflected vector as Vector2D","title":"Return value"},{"location":"Vector2D/#reversedv-object","text":"Returns a reversed Vector2D .","title":"reversed(v: object)"},{"location":"Vector2D/#parameters_11","text":"v: Vector2D to reverse","title":"Parameters"},{"location":"Vector2D/#return-value_9","text":"The reversed vector as Vector2D","title":"Return value"},{"location":"Vector2D/#properties","text":"","title":"Properties"},{"location":"Vector2D/#x","text":"The x value of the vector.","title":"x"},{"location":"Vector2D/#y","text":"The y value of the vector.","title":"y"},{"location":"Vector2D/#methods","text":"","title":"Methods"},{"location":"Vector2D/#getangle","text":"Returns the angle of the Vector2D in degree.","title":"getAngle()"},{"location":"Vector2D/#return-value_10","text":"The angle of the Vector2D in degree","title":"Return value"},{"location":"Vector2D/#getanglerad","text":"Returns the angle of the Vector2D in radians.","title":"getAngleRad()"},{"location":"Vector2D/#return-value_11","text":"The angle of the Vector2D in radians","title":"Return value"},{"location":"Vector2D/#getinversetransformedinvoffsetx-double-invoffsety-double-invscalex-double-invscaley-double","text":"Returns the inverse transformed vector as Vector2D .","title":"getInverseTransformed(invoffsetx: double, invoffsety: double, invscalex: double, invscaley: double)"},{"location":"Vector2D/#parameters_12","text":"invoffsetx: X offset invoffsety: Y offset invscalex: X scale invscaley: Y scale","title":"Parameters"},{"location":"Vector2D/#return-value_12","text":"The inverse transformed vector as Vector2D","title":"Return value"},{"location":"Vector2D/#getlength","text":"Returns the length of the Vector2D .","title":"getLength()"},{"location":"Vector2D/#return-value_13","text":"The length of the Vector2D","title":"Return value"},{"location":"Vector2D/#getlengthsq","text":"Returns the square length of the Vector2D .","title":"getLengthSq()"},{"location":"Vector2D/#return-value_14","text":"The square length of the Vector2D","title":"Return value"},{"location":"Vector2D/#getnormal","text":"Returns the normal of the Vector2D .","title":"getNormal()"},{"location":"Vector2D/#return-value_15","text":"The normal as Vector2D","title":"Return value"},{"location":"Vector2D/#getperpendicular","text":"Returns the perpendicular to the Vector2D .","title":"getPerpendicular()"},{"location":"Vector2D/#return-value_16","text":"The perpendicular as Vector2D","title":"Return value"},{"location":"Vector2D/#getrotatedtheta-double","text":"Returns the rotated vector as Vector2D .","title":"getRotated(theta: double)"},{"location":"Vector2D/#parameters_13","text":"theta: Angle in degree to rotate by","title":"Parameters"},{"location":"Vector2D/#return-value_17","text":"The rotated Vector2D","title":"Return value"},{"location":"Vector2D/#getrotatedradtheta-double","text":"Returns the rotated vector as Vector2D .","title":"getRotatedRad(theta: double)"},{"location":"Vector2D/#parameters_14","text":"theta: Angle in radians to rotate by","title":"Parameters"},{"location":"Vector2D/#return-value_18","text":"The rotated Vector2D","title":"Return value"},{"location":"Vector2D/#getsign","text":"Returns a Vector2D with the sign of all components.","title":"getSign()"},{"location":"Vector2D/#return-value_19","text":"A Vector2D with the sign of all components","title":"Return value"},{"location":"Vector2D/#gettransformedoffsetx-double-offsety-double-scalex-double-scaley-double","text":"Returns the transformed vector as Vector2D .","title":"getTransformed(offsetx: double, offsety: double, scalex: double, scaley: double)"},{"location":"Vector2D/#parameters_15","text":"offsetx: X offset offsety: Y offset scalex: X scale scaley: Y scale","title":"Parameters"},{"location":"Vector2D/#return-value_20","text":"The transformed vector as Vector2D","title":"Return value"},{"location":"Vector2D/#isfinite","text":"Checks if the Vector2D is finite or not.","title":"isFinite()"},{"location":"Vector2D/#return-value_21","text":"true if Vector2D is finite, otherwise false","title":"Return value"},{"location":"Vector3D/","text":"Vector3D Constructors Vector3D(x: double, y: double, z: double) Creates a new Vector3D from x and y coordinates let v = new UDB.Vector3D(32, 64, 128); Parameters x: The x coordinate y: The y coordinate z: The z coordinate Vector3D(v: object) Creates a new Vector3D from a point. let v = new UDB.Vector3D([ 32, 64, 128 ]); Parameters v: The vector to create the Vector3D from Static methods crossProduct(a: object, b: object) Returns the cross product of two Vector3D s. Parameters a: First Vector3D b: Second Vector3D Return value Cross product of the two vectors as Vector3D dotProduct(a: Vector3D, b: Vector3D) Returns the dot product of two Vector3D s. Parameters a: First Vector3D b: Second Vector3D Return value The dot product of the two vectors fromAngleXY(angle: double) Creates a Vector3D from an angle in radians, Parameters angle: Angle on the x/y axes in degrees Return value Vector as Vector3D fromAngleXYRad(angle: double) Creates a Vector3D from an angle in radians Parameters angle: Angle on the x/y axes in radians Return value Vector as Vector3D fromAngleXYZ(anglexy: double, anglez: double) Creates a Vector3D from two angles in degrees Parameters anglexy: Angle on the x/y axes in radians anglez: Angle on the z axis in radians Return value Vector as Vector3D fromAngleXYZRad(anglexy: double, anglez: double) Creates a Vector3D from two angles in radians Parameters anglexy: Angle on the x/y axes in radians anglez: Angle on the z axis in radians Return value Vector as Vector3D reflect(v: object, m: object) Reflects a Vector3D over a mirror Vector3D . Parameters v: Vector3D to reflect m: Mirror Vector3D Return value The reflected vector as Vector3D reversed(v: object) Returns a reversed Vector3D . Parameters v: Vector3D to reverse Return value The reversed vector as Vector3D Properties x The x value of the vector. y The y value of the vector. z The z value of the vector. Methods getAngleXY() Returns the angle of the Vector3D in degrees. Return value The angle of the Vector3D in degrees getAngleXYRad() Returns the x/y angle of the Vector3D in radians. Return value The x/y angle of the Vector3D in radians getAngleZ() Returns the z angle of the Vector3D in degrees. Return value The z angle of the Vector3D in degrees getAngleZRad() Returns the z angle of the Vector3D in radians. Return value The z angle of the Vector3D in radians getLength() Returns the length of the Vector3D . Return value The length of the Vector3D getLengthSq() Returns the square length of the Vector3D . Return value The square length of the Vector3D getNormal() Returns the normal of the Vector3D . Return value The normal as Vector3D getScaled(scale: double) Return the scaled Vector3D . Parameters scale: Scale, where 1.0 is unscaled Return value The scaled Vector3D isFinite() Checks if the Vector3D is finite or not. Return value true if Vector3D is finite, otherwise false isNormalized() Checks if the Vector3D is normalized or not. Return value true if Vector3D is normalized, otherwise false","title":"Vector3D"},{"location":"Vector3D/#vector3d","text":"","title":"Vector3D"},{"location":"Vector3D/#constructors","text":"","title":"Constructors"},{"location":"Vector3D/#vector3dx-double-y-double-z-double","text":"Creates a new Vector3D from x and y coordinates let v = new UDB.Vector3D(32, 64, 128);","title":"Vector3D(x: double, y: double, z: double)"},{"location":"Vector3D/#parameters","text":"x: The x coordinate y: The y coordinate z: The z coordinate","title":"Parameters"},{"location":"Vector3D/#vector3dv-object","text":"Creates a new Vector3D from a point. let v = new UDB.Vector3D([ 32, 64, 128 ]);","title":"Vector3D(v: object)"},{"location":"Vector3D/#parameters_1","text":"v: The vector to create the Vector3D from","title":"Parameters"},{"location":"Vector3D/#static-methods","text":"","title":"Static methods"},{"location":"Vector3D/#crossproducta-object-b-object","text":"Returns the cross product of two Vector3D s.","title":"crossProduct(a: object, b: object)"},{"location":"Vector3D/#parameters_2","text":"a: First Vector3D b: Second Vector3D","title":"Parameters"},{"location":"Vector3D/#return-value","text":"Cross product of the two vectors as Vector3D","title":"Return value"},{"location":"Vector3D/#dotproducta-vector3d-b-vector3d","text":"Returns the dot product of two Vector3D s.","title":"dotProduct(a: Vector3D, b: Vector3D)"},{"location":"Vector3D/#parameters_3","text":"a: First Vector3D b: Second Vector3D","title":"Parameters"},{"location":"Vector3D/#return-value_1","text":"The dot product of the two vectors","title":"Return value"},{"location":"Vector3D/#fromanglexyangle-double","text":"Creates a Vector3D from an angle in radians,","title":"fromAngleXY(angle: double)"},{"location":"Vector3D/#parameters_4","text":"angle: Angle on the x/y axes in degrees","title":"Parameters"},{"location":"Vector3D/#return-value_2","text":"Vector as Vector3D","title":"Return value"},{"location":"Vector3D/#fromanglexyradangle-double","text":"Creates a Vector3D from an angle in radians","title":"fromAngleXYRad(angle: double)"},{"location":"Vector3D/#parameters_5","text":"angle: Angle on the x/y axes in radians","title":"Parameters"},{"location":"Vector3D/#return-value_3","text":"Vector as Vector3D","title":"Return value"},{"location":"Vector3D/#fromanglexyzanglexy-double-anglez-double","text":"Creates a Vector3D from two angles in degrees","title":"fromAngleXYZ(anglexy: double, anglez: double)"},{"location":"Vector3D/#parameters_6","text":"anglexy: Angle on the x/y axes in radians anglez: Angle on the z axis in radians","title":"Parameters"},{"location":"Vector3D/#return-value_4","text":"Vector as Vector3D","title":"Return value"},{"location":"Vector3D/#fromanglexyzradanglexy-double-anglez-double","text":"Creates a Vector3D from two angles in radians","title":"fromAngleXYZRad(anglexy: double, anglez: double)"},{"location":"Vector3D/#parameters_7","text":"anglexy: Angle on the x/y axes in radians anglez: Angle on the z axis in radians","title":"Parameters"},{"location":"Vector3D/#return-value_5","text":"Vector as Vector3D","title":"Return value"},{"location":"Vector3D/#reflectv-object-m-object","text":"Reflects a Vector3D over a mirror Vector3D .","title":"reflect(v: object, m: object)"},{"location":"Vector3D/#parameters_8","text":"v: Vector3D to reflect m: Mirror Vector3D","title":"Parameters"},{"location":"Vector3D/#return-value_6","text":"The reflected vector as Vector3D","title":"Return value"},{"location":"Vector3D/#reversedv-object","text":"Returns a reversed Vector3D .","title":"reversed(v: object)"},{"location":"Vector3D/#parameters_9","text":"v: Vector3D to reverse","title":"Parameters"},{"location":"Vector3D/#return-value_7","text":"The reversed vector as Vector3D","title":"Return value"},{"location":"Vector3D/#properties","text":"","title":"Properties"},{"location":"Vector3D/#x","text":"The x value of the vector.","title":"x"},{"location":"Vector3D/#y","text":"The y value of the vector.","title":"y"},{"location":"Vector3D/#z","text":"The z value of the vector.","title":"z"},{"location":"Vector3D/#methods","text":"","title":"Methods"},{"location":"Vector3D/#getanglexy","text":"Returns the angle of the Vector3D in degrees.","title":"getAngleXY()"},{"location":"Vector3D/#return-value_8","text":"The angle of the Vector3D in degrees","title":"Return value"},{"location":"Vector3D/#getanglexyrad","text":"Returns the x/y angle of the Vector3D in radians.","title":"getAngleXYRad()"},{"location":"Vector3D/#return-value_9","text":"The x/y angle of the Vector3D in radians","title":"Return value"},{"location":"Vector3D/#getanglez","text":"Returns the z angle of the Vector3D in degrees.","title":"getAngleZ()"},{"location":"Vector3D/#return-value_10","text":"The z angle of the Vector3D in degrees","title":"Return value"},{"location":"Vector3D/#getanglezrad","text":"Returns the z angle of the Vector3D in radians.","title":"getAngleZRad()"},{"location":"Vector3D/#return-value_11","text":"The z angle of the Vector3D in radians","title":"Return value"},{"location":"Vector3D/#getlength","text":"Returns the length of the Vector3D .","title":"getLength()"},{"location":"Vector3D/#return-value_12","text":"The length of the Vector3D","title":"Return value"},{"location":"Vector3D/#getlengthsq","text":"Returns the square length of the Vector3D .","title":"getLengthSq()"},{"location":"Vector3D/#return-value_13","text":"The square length of the Vector3D","title":"Return value"},{"location":"Vector3D/#getnormal","text":"Returns the normal of the Vector3D .","title":"getNormal()"},{"location":"Vector3D/#return-value_14","text":"The normal as Vector3D","title":"Return value"},{"location":"Vector3D/#getscaledscale-double","text":"Return the scaled Vector3D .","title":"getScaled(scale: double)"},{"location":"Vector3D/#parameters_10","text":"scale: Scale, where 1.0 is unscaled","title":"Parameters"},{"location":"Vector3D/#return-value_15","text":"The scaled Vector3D","title":"Return value"},{"location":"Vector3D/#isfinite","text":"Checks if the Vector3D is finite or not.","title":"isFinite()"},{"location":"Vector3D/#return-value_16","text":"true if Vector3D is finite, otherwise false","title":"Return value"},{"location":"Vector3D/#isnormalized","text":"Checks if the Vector3D is normalized or not.","title":"isNormalized()"},{"location":"Vector3D/#return-value_17","text":"true if Vector3D is normalized, otherwise false","title":"Return value"},{"location":"Vertex/","text":"Vertex Properties ceilingZ The ceiling z position of the Vertex . Only available in UDMF. Only available for supported game configurations. fields UDMF fields. It's an object with the fields as properties. s.fields.comment = 'This is a comment'; s.fields['comment'] = 'This is a comment'; // Also works s.fields.xscalefloor = 2.0; t.fields.score = 100; It is also possible to define new fields: s.fields.user_myboolfield = true; There are some restrictions, though: it only works for fields that are not in the base UDMF standard, since those are handled directly in the respective class it does not work for flags. While they are technically also UDMF fields, they are handled in the flags field of the respective class (where applicable) JavaScript does not distinguish between integer and floating point numbers, it only has floating point numbers (of double precision). For fields where UDB knows that they are integers this it not a problem, since it'll automatically convert the floating point numbers to integers (dropping the fractional part). However, if you need to specify an integer value for an unknown or custom field you have to work around this limitation: Version 5 and later: You can use a BigInt . This is done by appending a n to the number. Note that this is just a convenient way to define whole numbers, it still only supports 32 bit integers: s.fields.user_myintfield = 25n; // Sets the 'user_myintfield' field to an integer value of 25 In version 4 and earlier you have to use the UniValue class: s.fields.user_myintfield = new UDB.UniValue(0, 25); // Sets the 'user_myintfield' field to an integer value of 25 To remove a field you have to assign null to it: s.fields.user_myintfield = null; floorZ The floor z position of the Vertex . Only available in UDMF. Only available for supported game configurations. index The vertex index. Read-only. marked If the Vertex is marked or not. It is used to mark map elements that were created or changed (for example after drawing new geometry). position Position of the Vertex . It's an object with x and y properties. The x and y accept numbers: v.position.x = 32; v.position.y = 64; It's also possible to set all fields immediately by assigning either a Vector2D , or an array of numbers: v.position = new UDB.Vector2D(32, 64); v.position = [ 32, 64 ]; selected If the Vertex is selected or not. Methods copyPropertiesTo(v: Vertex) Copies the properties from this Vertex to another. Parameters v: the vertex to copy the properties to delete() Deletes the Vertex . Note that this can result in unclosed sectors. distanceTo(pos: object) Gets the distance between this Vertex and the given point. The point can be either a Vector2D or an array of numbers. v.distanceTo(new UDB.Vector2D(32, 64)); v.distanceTo([ 32, 64 ]); Parameters pos: Point to calculate the distance to. Return value Distance to pos distanceToSq(pos: object) Gets the squared distance between this Vertex and the given point. The point can be either a Vector2D or an array of numbers. v.distanceToSq(new UDB.Vector2D(32, 64)); v.distanceToSq([ 32, 64 ]); Parameters pos: Point to calculate the squared distance to. Return value Squared distance to pos getLinedefs() Gets all Linedefs that are connected to this Vertex . Return value Array of linedefs join(other: Vertex) Joins this Vertex with another Vertex , deleting this Vertex and keeping the other. Parameters other: Vertex to join with nearestLinedef(pos: object) Returns the Linedef that is connected to this Vertex that is closest to the given point. Parameters pos: Point to get the nearest Linedef connected to this Vertex from Return value missing snapToAccuracy() Snaps the Vertex 's position to the map format's accuracy. snapToGrid() Snaps the Vertex 's position to the grid.","title":"Vertex"},{"location":"Vertex/#vertex","text":"","title":"Vertex"},{"location":"Vertex/#properties","text":"","title":"Properties"},{"location":"Vertex/#ceilingz","text":"The ceiling z position of the Vertex . Only available in UDMF. Only available for supported game configurations.","title":"ceilingZ"},{"location":"Vertex/#fields","text":"UDMF fields. It's an object with the fields as properties. s.fields.comment = 'This is a comment'; s.fields['comment'] = 'This is a comment'; // Also works s.fields.xscalefloor = 2.0; t.fields.score = 100; It is also possible to define new fields: s.fields.user_myboolfield = true; There are some restrictions, though: it only works for fields that are not in the base UDMF standard, since those are handled directly in the respective class it does not work for flags. While they are technically also UDMF fields, they are handled in the flags field of the respective class (where applicable) JavaScript does not distinguish between integer and floating point numbers, it only has floating point numbers (of double precision). For fields where UDB knows that they are integers this it not a problem, since it'll automatically convert the floating point numbers to integers (dropping the fractional part). However, if you need to specify an integer value for an unknown or custom field you have to work around this limitation: Version 5 and later: You can use a BigInt . This is done by appending a n to the number. Note that this is just a convenient way to define whole numbers, it still only supports 32 bit integers: s.fields.user_myintfield = 25n; // Sets the 'user_myintfield' field to an integer value of 25 In version 4 and earlier you have to use the UniValue class: s.fields.user_myintfield = new UDB.UniValue(0, 25); // Sets the 'user_myintfield' field to an integer value of 25 To remove a field you have to assign null to it: s.fields.user_myintfield = null;","title":"fields"},{"location":"Vertex/#floorz","text":"The floor z position of the Vertex . Only available in UDMF. Only available for supported game configurations.","title":"floorZ"},{"location":"Vertex/#index","text":"The vertex index. Read-only.","title":"index"},{"location":"Vertex/#marked","text":"If the Vertex is marked or not. It is used to mark map elements that were created or changed (for example after drawing new geometry).","title":"marked"},{"location":"Vertex/#position","text":"Position of the Vertex . It's an object with x and y properties. The x and y accept numbers: v.position.x = 32; v.position.y = 64; It's also possible to set all fields immediately by assigning either a Vector2D , or an array of numbers: v.position = new UDB.Vector2D(32, 64); v.position = [ 32, 64 ];","title":"position"},{"location":"Vertex/#selected","text":"If the Vertex is selected or not.","title":"selected"},{"location":"Vertex/#methods","text":"","title":"Methods"},{"location":"Vertex/#copypropertiestov-vertex","text":"Copies the properties from this Vertex to another.","title":"copyPropertiesTo(v: Vertex)"},{"location":"Vertex/#parameters","text":"v: the vertex to copy the properties to","title":"Parameters"},{"location":"Vertex/#delete","text":"Deletes the Vertex . Note that this can result in unclosed sectors.","title":"delete()"},{"location":"Vertex/#distancetopos-object","text":"Gets the distance between this Vertex and the given point. The point can be either a Vector2D or an array of numbers. v.distanceTo(new UDB.Vector2D(32, 64)); v.distanceTo([ 32, 64 ]);","title":"distanceTo(pos: object)"},{"location":"Vertex/#parameters_1","text":"pos: Point to calculate the distance to.","title":"Parameters"},{"location":"Vertex/#return-value","text":"Distance to pos","title":"Return value"},{"location":"Vertex/#distancetosqpos-object","text":"Gets the squared distance between this Vertex and the given point. The point can be either a Vector2D or an array of numbers. v.distanceToSq(new UDB.Vector2D(32, 64)); v.distanceToSq([ 32, 64 ]);","title":"distanceToSq(pos: object)"},{"location":"Vertex/#parameters_2","text":"pos: Point to calculate the squared distance to.","title":"Parameters"},{"location":"Vertex/#return-value_1","text":"Squared distance to pos","title":"Return value"},{"location":"Vertex/#getlinedefs","text":"Gets all Linedefs that are connected to this Vertex .","title":"getLinedefs()"},{"location":"Vertex/#return-value_2","text":"Array of linedefs","title":"Return value"},{"location":"Vertex/#joinother-vertex","text":"Joins this Vertex with another Vertex , deleting this Vertex and keeping the other.","title":"join(other: Vertex)"},{"location":"Vertex/#parameters_3","text":"other: Vertex to join with","title":"Parameters"},{"location":"Vertex/#nearestlinedefpos-object","text":"Returns the Linedef that is connected to this Vertex that is closest to the given point.","title":"nearestLinedef(pos: object)"},{"location":"Vertex/#parameters_4","text":"pos: Point to get the nearest Linedef connected to this Vertex from","title":"Parameters"},{"location":"Vertex/#return-value_3","text":"missing","title":"Return value"},{"location":"Vertex/#snaptoaccuracy","text":"Snaps the Vertex 's position to the map format's accuracy.","title":"snapToAccuracy()"},{"location":"Vertex/#snaptogrid","text":"Snaps the Vertex 's position to the grid.","title":"snapToGrid()"},{"location":"VisualCamera/","text":"VisualCamera Properties angleXY Angle of the camera on the X/Y axes. Read-only. angleZ Angle of the camera on the Z axis. Read-only. position Position of the camera as Vector3D . Read-only.","title":"VisualCamera"},{"location":"VisualCamera/#visualcamera","text":"","title":"VisualCamera"},{"location":"VisualCamera/#properties","text":"","title":"Properties"},{"location":"VisualCamera/#anglexy","text":"Angle of the camera on the X/Y axes. Read-only.","title":"angleXY"},{"location":"VisualCamera/#anglez","text":"Angle of the camera on the Z axis. Read-only.","title":"angleZ"},{"location":"VisualCamera/#position","text":"Position of the camera as Vector3D . Read-only.","title":"position"},{"location":"changes/","text":"Changes This site lists all changes between different API version of UDBScript Version 5 Added Plane class Added BlockMap , BlockEntry , and BlackMapQueryResult classes Sector class Added getLabelPositions method to get the position of sector labels (where tags, effects etc. are displayed) Added support for JavaScript BigInt for UDMF fields. This means it's not necessary anymore to use UniValue to assign integers to new UDMF fields. Instead it can be done like this: sector.fields.my_int_field = 1n; Added type information file (udbscript.d.ts) Version 4 Moved all classes, object, and methods into the UDB namespace (everything has to be prefixed wiht UDB. ) Added methods to report progress for long running scripts and script log output. See Communicating with the user for more information Version 3 Exported the classes Linedef , Sector , Sidedef , Thing , and Vertex , so that they can be used with instanceof Map class The getSidedefsFromSelectedLinedefs() method now correctly only returns the Sidedef s of selected Linedef s in visual mode (and not also the highlighted one) Added a new getSidedefsFromSelectedOrHighlightedLinedefs() method as the equivalent to the other getSelectedOrHighlighted*() methods Sector class Added new floorSelected , ceilingSelected , floorHighlighted , and ceilingHighlighted properties. Those are mostly useful in visual mode, since they always return true when the Sector is selected or highlighted in the classic modes. The properties are read-only Sidedef class Added new upperSelected , middleSelected , lowerSelected , upperHighlighted , middleHighlighted , and lowerHighlighted properties. Those are mostly useful in visual mode, since they always return true when the parent Linedef is selected or highlighted in the classic modes. The properties are read-only Version 2 Pen built-in library The methods of the Pen class now return the instance of the Pen class to allow method chaining","title":"Changes"},{"location":"changes/#changes","text":"This site lists all changes between different API version of UDBScript","title":"Changes"},{"location":"changes/#version-5","text":"Added Plane class Added BlockMap , BlockEntry , and BlackMapQueryResult classes Sector class Added getLabelPositions method to get the position of sector labels (where tags, effects etc. are displayed) Added support for JavaScript BigInt for UDMF fields. This means it's not necessary anymore to use UniValue to assign integers to new UDMF fields. Instead it can be done like this: sector.fields.my_int_field = 1n; Added type information file (udbscript.d.ts)","title":"Version 5"},{"location":"changes/#version-4","text":"Moved all classes, object, and methods into the UDB namespace (everything has to be prefixed wiht UDB. ) Added methods to report progress for long running scripts and script log output. See Communicating with the user for more information","title":"Version 4"},{"location":"changes/#version-3","text":"Exported the classes Linedef , Sector , Sidedef , Thing , and Vertex , so that they can be used with instanceof Map class The getSidedefsFromSelectedLinedefs() method now correctly only returns the Sidedef s of selected Linedef s in visual mode (and not also the highlighted one) Added a new getSidedefsFromSelectedOrHighlightedLinedefs() method as the equivalent to the other getSelectedOrHighlighted*() methods Sector class Added new floorSelected , ceilingSelected , floorHighlighted , and ceilingHighlighted properties. Those are mostly useful in visual mode, since they always return true when the Sector is selected or highlighted in the classic modes. The properties are read-only Sidedef class Added new upperSelected , middleSelected , lowerSelected , upperHighlighted , middleHighlighted , and lowerHighlighted properties. Those are mostly useful in visual mode, since they always return true when the parent Linedef is selected or highlighted in the classic modes. The properties are read-only","title":"Version 3"},{"location":"changes/#version-2","text":"Pen built-in library The methods of the Pen class now return the instance of the Pen class to allow method chaining","title":"Version 2"},{"location":"gettingstarted/","text":"Getting started Introduction UDBScript allows the user to run custom JavaScript code on the currently opened map. This allowes the user to modify existing map elements (like things or sectors), or to create completely new map elements (i.e. drawing lines, adding things etc.). This guide only shows the intricacies of UDBScript and doesn't teach JavaScript. If you need a JavaScript tutorial please use your favourite search engine. UDBScript also comes with a variety of well-documented example scripts to study. UDBScript uses the Jint interpreter. Directory structure Scripts are automatically found if they are placed in the correct directory structure. The directory structure is in the UDB installation folder and looks like this: .\\UDBScript\\ .\\UDBScript\\Libraries\\ .\\UDBScript\\Scripts\\ All files ending on .js in the Libraries directory are loaded (parsed and executed) every time a script is run. It is used to provide common functionality to multiple script. Currently there's the Pen.js library file that simplifies drawing geometry (it's inspired by the DBX Lua Pen class). All files ending on .js in the Scripts directory (and its subdirectories) are added to the Scripts docker. They are only run on the user's command. Tip UDBScript does hot reloading, i.e. changes to the scripts, or copying new scripts into the directory structure will be shown immediately. Warning UDBScript comes with multiple example scripts in the .\\UDBScript\\Scripts\\Examples directory. Do not modify those scripts, since they will be overwritten when UDB is updated. If you want to use one of the example scripts as a bas copy it to another directory! Setting hotkeys to execute scripts Hotkeys to execute scripts can be set by going to Tools -> Preferences -> Controls , and then filtering by execute . You can set a hotkey to \"Execute Script\", which will execute the currently selected script in the docker (see The docker ), or up to 30 hotkeys to the \"Execute Script Slot x \", which will execute the script in the corrosponding slots (see The docker ). Setting up an external script editor It is possible to set up an external script editor to edit the script from within UDB. To do so you have to open the preferences and go to the UDBScript tab (you probably have to scroll the tabs). It defaults to notepad.exe, but it's recommended to set it to an editor that supports syntax highlighting. The docker Scripts can be accessed, configured, and run through the provided docker. Selecting a script will show it's description (if available) and configuration options. Default values in the script options will be shown in gray, deviating values as black. Pressing the Reset button will reset all values to their defaults. Scripts can either be run using the Run button, or by pressing the assigned key (see Setting hotkeys to execute scripts ). Note that scripts might rely on the mouse cursor being somewhere in the map space, in which case they will not run correctly using the Run button. This should be intercepted by the script. You can open a context menu for each script by right-clicking on it. In the context menu you can either chose to edit the script, or to assign the script to one of the script slots. Assigning the script to a script slot allows you to execute the script by pressing the hotkey you assigned to the script slot (see Setting hotkeys to execute scripts ). Writing scripts Type information file (udbscript.d.ts) UDBScript comes with a type information called udbscript.d.ts located in the UDBScript directory in the UDB installation directory. This file contains information about the available classes, methods, and their parameters. This makes writing scripts more comfortable if you are using an text editor that can interpret this file, such as Visual Studio Code. To use the file it has to be referenced at the very top of the script file: /// <reference path=\"../udbscript.d.ts\" /> Depending on where your script is located you have to change the path to the file. Attention .d.ts files are originally for the TypeScript programming language, which is a superset of JavaScript. UDBScript does not support TypeScript, it merely provides a definition file to make writing scripts easier. Script metadata Scripts can contain metadata at the top of the file to provide information about the script as well as available script options. The metadata is specified as JavaScript template strings, i.e. strings enclosed by backticks ( ` ). The template string has to start with a # , followed by a command, followed by the payload, followed by a ; . Attention The template string has to be followed by a ; . All script metadata has to be at the top of the file and may not be interrupted by any other constructs (like variable declaraion or assignment). If such constructs are detected parsing of the metadata will stop. Example: `#version 2`; `#name Super Useful Script`; `#description This script does something really, really useful.`; Currently the following metadata commands are available: version : the feature version the script needs to run. Properties and methods that require a specific version are noted as such in the API documentation. If omitted version 1 is assumed. If the script requires a higher feature version than the user's UDBScript feature version the user will be asked if they want to execute the script anyway. If the user choses to execute the script this choice will be remembered for the session name : name of the script that will be shown in the docker. If omitted the capitalized file name without the extension will be used as the script name description : description of the script. Should include what the script does and what the requirements are (for example if something has to be selected for the script to work) scriptoptions : the script options. The payload has to be in UDB's configuration file format (see below) Attention It is highliy recommended to set the feature version through the version metadata command. The global UDB namespace was added in version 4, and new features will be exclusively added to this namespace! Setting script options The script options that can be set in the docker prior to running the script can be defined using the scriptoptions metadata command. The payload has to be in UDB's configuration file format. The payload consists of one or more blocks, each defining an option. The blocks have the following format: `#scriptoptions <name> { description = <description>; default = <defaultvalue>; type = <type>; enumvalues { <values> } } `; Note The eunumvalues field is only used with the appropriate type value Example: `#scriptoptions length { description = \"Length of closet\"; default = 256; type = 0; // Integer } direction { description = \"Direction of closet\"; default = 0; // North type = 11; // Enum enumvalues { 0 = \"North\"; 1 = \"East\"; 2 = \"South\"; 3 = \"West\"; } } `; You can also write the options in a more compact form: `#scriptoptions width { description = \"Width of the sector\"; type = 0; default = 256; } height { description = \"Height of the sector\"; type = 0; default = 512; } `; The following types are currently available: 0: integer 1: floating point number 2: string 3: boolean 5: sector effect* 6: texture* 7: flat* 8: angle in degrees* 9: angle in radians* 10: color* 11: enumeration** 13: sector tag* 14: thing tag* 15: linedef tag* 17: angle in degrees as floating point number* 18: thing type* 19: thing class* 22: byte angle* 25: PolyObject number* * these are quality of life type for interger, floating point numbers, and strings. Clicking into their field will show context sensitive controls. For example when using type 3 (boolean) there will be drop down list where you can choose between true or false , when using type 6 (texture) a button button that will open the texture browser, when using type 13 (sector tag) will show a drop down list of sector tags in the map etc. Accessing script options in a script The script option can be accessed through the ScriptOptions object in the global UDB namespace. This object has properties by the name of the blocks of the script option definition, and contains the value set in the docker. Example: `#scriptoptions length { description = \"Length of closet\"; default = 256; type = 0; // Integer } `; UDB.showMessage('The given length is ' + UDB.ScriptOptions.length); Tip You can also query options at runtime. See the QueryOptions API documentation. The global UDB namespace Starting with feature version 4 of UDBScript all objects, methods, and classes are combined in the global UDB namespace. This is to prevent clashes with existing and future features of Javascript (for example Javascript has a Map class). It is highly recommended to specify the feature version through the version metadata command (see above). New UDBScript features will only be added to the global UDB namespace. In practice that means that all methods, objects, and classes have to be prefixed with UDB. , for example getting all sectors in a map looked like this in versions prior to 4: let sectors = Map.getSectors(); while in version 4 and later the following code has to be used: let sectors = UDB.Map.getSectors(); Working with vectors In UDBScript vectors are commonly used to represent positions, like thing and vertex positions. They come in two flavors, Vector2D (representing a two-dimentional vector with x and y components) and Vector3D (representing a three-dimentional vector with x , y , and z components). They feature a range of vector math methods, such as rotating the vector. There are several ways to create a new vector: let v1 = new UDB.Vector2D(32, 64); // From x and y values let v2 = new UDB.Vector2D([ 32, 64 ]); // From an array with two numbers let v3 = new UDB.Vector2D({ x: 32, y: 64 }); // From an object with x and y properties let v4 = new UDB.Vector2D(v1); // From another Vector2D let v5 = new UDB.Vector3D(32, 64, 16); // From x, y, and z values let v6 = new UDB.Vector3D([ 32, 64, 16 ]); // From an array with three numbers let v7 = new UDB.Vector3D({ x: 32, y: 64, z: 16 }); // From an object with x, y, and z properties let v8 = new UDB.Vector3D(v5); // From another Vector3D API methods that accept a Vector2D or Vector3D as a parameter also accept the array notation. For example the following lines are equivalent: let t1 = UDB.Map.createThing(new UDB.Vector2D(32, 64), 3001); // Create an Imp let t2 = UDB.Map.createThing([ 32, 64 ], 3001); // Create an Imp let t3 = UDB.Map.createThing({ x: 32, y: 64 }, 3001); // Create an Imp let v = new UDB.Vector2D(32, 64); // Supplying the x and y values let t4 = UDB.Map.createThing(v, 3001); // Create an Imp Vector arithmetic It is possible to do elementary arithmetic with vectors, i.e. you can add, substract, multiply, and divide them. let v1 = new UDB.Vector2D(2, 3) + new UDB.Vector2D(4, 5); // Results in new Vector(6, 8) let v2 = new UDB.Vector2D(2, 3) - new UDB.Vector2D(4, 5); // Results in new Vector(-2, -2) let v3 = new UDB.Vector2D(2, 3) * new UDB.Vector2D(4, 5); // Results in new Vector(8, 15) let v4 = new UDB.Vector2D(2, 3) / new UDB.Vector2D(4, 5); // Results in new Vector(0.5, 0.6) This also works with the array and object notation: let v1 = new UDB.Vector2D(2, 3) + [ 4, 5 ]; // Results in new Vector(6, 8) let v2 = new UDB.Vector2D(2, 3) + { x: 4, y: 5 }; // Results in new Vector(6, 8) You can also use only a number as one side of the operation, in which case the operation will be applied to each element of the vector: let v1 = new UDB.Vector2D(2, 3) + 3; // Results in new Vector(5, 6) let v2 = new UDB.Vector2D(2, 3) * 3; // Results in new Vector(6, 9) Attention Vector arithmetic only works if either side of arithmetic operation is of type Vector2D or Vector3D . That means that for example the following code will not result in a vector: let v1 = [ 2, 3 ] + [ 4, 5 ]; // Results in the string \"2, 34, 5\" Working with map elements Map elements (things, sectors, linedefs, sidedefs, vertices) can be accessed through the UDB.Map object. This object has methods that return an array of map elements, for example UDB.Map.getSectors() returns an array of Sector objects, which are are all sectors in the map. There are also methods to get all selected (for example UDB.Map.getSelectedSectors() ) and marked (for example UDB.Map.getMarkedSectors() ), or the currently highlighted (for example UDB.Map.getHighlightedSector() ) map elements. There are also methods to get either the currently selected map elements, or the currently highlighted map elements (for example UDB.Map.getSelectedOrHighlightedSectors() ). These map elements can then be modified, see the documentation for the particular map element type in the API section. Note \"Marking\" a map element is a way to denote that something happened to this map element. For example when using the UDB.Map.drawLines() method all new geometry will be marked. Info UDB differentiates between \"selecting\" and \"highlighting\" map elements. \"Selecting\" means clicking on the map element, \"highlighting\" means just hovering the mouse on (or near) a map element. All the UDB.Map.getSelectedOrHighlighted...() methods behave like UDB usually works, i.e. if at least one map element is selected, the selected map elements will be returned (and the highlighted map element will be ignored), if no map elements are selected the highlighted map element will be returned. In most circumstances it is recommended to use the UDB.Map.getSelectedOrHighlighted...() to stay close to UDB's built-in actions. Creating new geometry New map geometry can be created with the drawLines() method of the UDB.Map object. It accepts an array of coordinates in map space. The coordinates can either by instances of Vector2D , Vector3D , or an array of numbers. Example 1: UDB.Map.drawLines([ new UDB.Vector2D(0, 0), new UDB.Vector2D(64, 0), new UDB.Vector2D(64, 64), new UDB.Vector2D(0, 64), new UDB.Vector2D(0, 0) ]); Example 2: UDB.Map.drawLines([ [ 0, 0 ], [ 64, 0 ], [ 64, 64 ], [ 0, 64 ], [ 0, 0 ] ]); Both examples are equivalent. The advantage of using Vector2D or Vector3D is that they have many math related methods built-in. Another method to draw geometry is using the Pen class - which itself is implemented as a library written in JavaScript. It's inspired by the DoomBuilder X class of the same name. It provides some quality of life features, since it creates coordinates relative to the current position - just like moving a pen around a sheet of paper, or Turtle graphics . Naive implementation of the above example using the Pen class: let p = new Pen(); p.moveTo([0, 0]); p.drawVertex(); p.moveTo([64, 0]); p.drawVertex(); p.moveTo([64, 64]); p.drawVertex(); p.moveTo([0, 64]); p.drawVertex(); p.finishDrawing(); Using the strenghts of the Pen class: let p = new Pen([0, 0]); for(let i=0; i < 4; i++) { p.drawVertex(); p.moveForward(64); p.turnRight(); } p.finishDrawing(); Ending scripts prematurely Normally a script ends when the last instruction is executed. But there can be situations where you want to end a script early. UDB.exit() : this global function ends the script with success. It can optionally take a string argument that is shown in the status bar upon ending the script UDB.die() : this global function ends the script with a failure. This means that it will undo any changes the script has made. It can optionally take a string argument that is shown in the status bar upon ending the script throw : throws an exception. Only ends the script if it's not caught in a try / catch block. If not caught it'll end the script with a failure. This means that it will undo any changes the script has made. The string given as a parameter is shown in the status bar upon ending the script let sectors = UDB.Map.getSelectedSectors(); if(sectors.length == 0) UDB.die('You have to select at least one sector'); UDB.exit('There were ' + sectors.length + ' sectors selected'); throw 'This part of the script should never be reached!'; Communicating with the user Sometimes you might want to let the script directly communicate with the user. To do that there are two functions, UDB.showMessage() and UDB.showMessageYesNo() . UDB.showMessage() : shows a message box with an \"OK\" button and the text given as the parameter UDB.showMessage('Hello, world!'); UDB.showMessageYesNo() : shows a message box with an \"Yes\" and \"No\" button and the text given as the parameter. Returns true if the \"Yes\" button was clicked, and false if the \"No\" button was clicked if(UDB.showMessageYesNo('Are you sure you want to replace all imps with Arch-Viles? That\\'s not remotely fair!')) { UDB.Map.getThings().filter(t => t.type == 3001).forEach(t => t.type=64); } For long-running scripts it's also possible to report the progress to the user using the UDB.setProgress() method, which accepts values from 0 to 100. For example the following code will set the progress bar to 25%: UDB.setProgress(25); Additional output can be shown using the UDB.log() method, which will add a line of text to the log in the running script dialog: UDB.log('Hello, world!');","title":"Getting started"},{"location":"gettingstarted/#getting-started","text":"","title":"Getting started"},{"location":"gettingstarted/#introduction","text":"UDBScript allows the user to run custom JavaScript code on the currently opened map. This allowes the user to modify existing map elements (like things or sectors), or to create completely new map elements (i.e. drawing lines, adding things etc.). This guide only shows the intricacies of UDBScript and doesn't teach JavaScript. If you need a JavaScript tutorial please use your favourite search engine. UDBScript also comes with a variety of well-documented example scripts to study. UDBScript uses the Jint interpreter.","title":"Introduction"},{"location":"gettingstarted/#directory-structure","text":"Scripts are automatically found if they are placed in the correct directory structure. The directory structure is in the UDB installation folder and looks like this: .\\UDBScript\\ .\\UDBScript\\Libraries\\ .\\UDBScript\\Scripts\\ All files ending on .js in the Libraries directory are loaded (parsed and executed) every time a script is run. It is used to provide common functionality to multiple script. Currently there's the Pen.js library file that simplifies drawing geometry (it's inspired by the DBX Lua Pen class). All files ending on .js in the Scripts directory (and its subdirectories) are added to the Scripts docker. They are only run on the user's command. Tip UDBScript does hot reloading, i.e. changes to the scripts, or copying new scripts into the directory structure will be shown immediately. Warning UDBScript comes with multiple example scripts in the .\\UDBScript\\Scripts\\Examples directory. Do not modify those scripts, since they will be overwritten when UDB is updated. If you want to use one of the example scripts as a bas copy it to another directory!","title":"Directory structure"},{"location":"gettingstarted/#setting-hotkeys-to-execute-scripts","text":"Hotkeys to execute scripts can be set by going to Tools -> Preferences -> Controls , and then filtering by execute . You can set a hotkey to \"Execute Script\", which will execute the currently selected script in the docker (see The docker ), or up to 30 hotkeys to the \"Execute Script Slot x \", which will execute the script in the corrosponding slots (see The docker ).","title":"Setting hotkeys to execute scripts"},{"location":"gettingstarted/#setting-up-an-external-script-editor","text":"It is possible to set up an external script editor to edit the script from within UDB. To do so you have to open the preferences and go to the UDBScript tab (you probably have to scroll the tabs). It defaults to notepad.exe, but it's recommended to set it to an editor that supports syntax highlighting.","title":"Setting up an external script editor"},{"location":"gettingstarted/#the-docker","text":"Scripts can be accessed, configured, and run through the provided docker. Selecting a script will show it's description (if available) and configuration options. Default values in the script options will be shown in gray, deviating values as black. Pressing the Reset button will reset all values to their defaults. Scripts can either be run using the Run button, or by pressing the assigned key (see Setting hotkeys to execute scripts ). Note that scripts might rely on the mouse cursor being somewhere in the map space, in which case they will not run correctly using the Run button. This should be intercepted by the script. You can open a context menu for each script by right-clicking on it. In the context menu you can either chose to edit the script, or to assign the script to one of the script slots. Assigning the script to a script slot allows you to execute the script by pressing the hotkey you assigned to the script slot (see Setting hotkeys to execute scripts ).","title":"The docker"},{"location":"gettingstarted/#writing-scripts","text":"","title":"Writing scripts"},{"location":"gettingstarted/#type-information-file-udbscriptdts","text":"UDBScript comes with a type information called udbscript.d.ts located in the UDBScript directory in the UDB installation directory. This file contains information about the available classes, methods, and their parameters. This makes writing scripts more comfortable if you are using an text editor that can interpret this file, such as Visual Studio Code. To use the file it has to be referenced at the very top of the script file: /// <reference path=\"../udbscript.d.ts\" /> Depending on where your script is located you have to change the path to the file. Attention .d.ts files are originally for the TypeScript programming language, which is a superset of JavaScript. UDBScript does not support TypeScript, it merely provides a definition file to make writing scripts easier.","title":"Type information file (udbscript.d.ts)"},{"location":"gettingstarted/#script-metadata","text":"Scripts can contain metadata at the top of the file to provide information about the script as well as available script options. The metadata is specified as JavaScript template strings, i.e. strings enclosed by backticks ( ` ). The template string has to start with a # , followed by a command, followed by the payload, followed by a ; . Attention The template string has to be followed by a ; . All script metadata has to be at the top of the file and may not be interrupted by any other constructs (like variable declaraion or assignment). If such constructs are detected parsing of the metadata will stop. Example: `#version 2`; `#name Super Useful Script`; `#description This script does something really, really useful.`; Currently the following metadata commands are available: version : the feature version the script needs to run. Properties and methods that require a specific version are noted as such in the API documentation. If omitted version 1 is assumed. If the script requires a higher feature version than the user's UDBScript feature version the user will be asked if they want to execute the script anyway. If the user choses to execute the script this choice will be remembered for the session name : name of the script that will be shown in the docker. If omitted the capitalized file name without the extension will be used as the script name description : description of the script. Should include what the script does and what the requirements are (for example if something has to be selected for the script to work) scriptoptions : the script options. The payload has to be in UDB's configuration file format (see below) Attention It is highliy recommended to set the feature version through the version metadata command. The global UDB namespace was added in version 4, and new features will be exclusively added to this namespace!","title":"Script metadata"},{"location":"gettingstarted/#setting-script-options","text":"The script options that can be set in the docker prior to running the script can be defined using the scriptoptions metadata command. The payload has to be in UDB's configuration file format. The payload consists of one or more blocks, each defining an option. The blocks have the following format: `#scriptoptions <name> { description = <description>; default = <defaultvalue>; type = <type>; enumvalues { <values> } } `; Note The eunumvalues field is only used with the appropriate type value Example: `#scriptoptions length { description = \"Length of closet\"; default = 256; type = 0; // Integer } direction { description = \"Direction of closet\"; default = 0; // North type = 11; // Enum enumvalues { 0 = \"North\"; 1 = \"East\"; 2 = \"South\"; 3 = \"West\"; } } `; You can also write the options in a more compact form: `#scriptoptions width { description = \"Width of the sector\"; type = 0; default = 256; } height { description = \"Height of the sector\"; type = 0; default = 512; } `; The following types are currently available: 0: integer 1: floating point number 2: string 3: boolean 5: sector effect* 6: texture* 7: flat* 8: angle in degrees* 9: angle in radians* 10: color* 11: enumeration** 13: sector tag* 14: thing tag* 15: linedef tag* 17: angle in degrees as floating point number* 18: thing type* 19: thing class* 22: byte angle* 25: PolyObject number* * these are quality of life type for interger, floating point numbers, and strings. Clicking into their field will show context sensitive controls. For example when using type 3 (boolean) there will be drop down list where you can choose between true or false , when using type 6 (texture) a button button that will open the texture browser, when using type 13 (sector tag) will show a drop down list of sector tags in the map etc.","title":"Setting script options"},{"location":"gettingstarted/#accessing-script-options-in-a-script","text":"The script option can be accessed through the ScriptOptions object in the global UDB namespace. This object has properties by the name of the blocks of the script option definition, and contains the value set in the docker. Example: `#scriptoptions length { description = \"Length of closet\"; default = 256; type = 0; // Integer } `; UDB.showMessage('The given length is ' + UDB.ScriptOptions.length); Tip You can also query options at runtime. See the QueryOptions API documentation.","title":"Accessing script options in a script"},{"location":"gettingstarted/#the-global-udb-namespace","text":"Starting with feature version 4 of UDBScript all objects, methods, and classes are combined in the global UDB namespace. This is to prevent clashes with existing and future features of Javascript (for example Javascript has a Map class). It is highly recommended to specify the feature version through the version metadata command (see above). New UDBScript features will only be added to the global UDB namespace. In practice that means that all methods, objects, and classes have to be prefixed with UDB. , for example getting all sectors in a map looked like this in versions prior to 4: let sectors = Map.getSectors(); while in version 4 and later the following code has to be used: let sectors = UDB.Map.getSectors();","title":"The global UDB namespace"},{"location":"gettingstarted/#working-with-vectors","text":"In UDBScript vectors are commonly used to represent positions, like thing and vertex positions. They come in two flavors, Vector2D (representing a two-dimentional vector with x and y components) and Vector3D (representing a three-dimentional vector with x , y , and z components). They feature a range of vector math methods, such as rotating the vector. There are several ways to create a new vector: let v1 = new UDB.Vector2D(32, 64); // From x and y values let v2 = new UDB.Vector2D([ 32, 64 ]); // From an array with two numbers let v3 = new UDB.Vector2D({ x: 32, y: 64 }); // From an object with x and y properties let v4 = new UDB.Vector2D(v1); // From another Vector2D let v5 = new UDB.Vector3D(32, 64, 16); // From x, y, and z values let v6 = new UDB.Vector3D([ 32, 64, 16 ]); // From an array with three numbers let v7 = new UDB.Vector3D({ x: 32, y: 64, z: 16 }); // From an object with x, y, and z properties let v8 = new UDB.Vector3D(v5); // From another Vector3D API methods that accept a Vector2D or Vector3D as a parameter also accept the array notation. For example the following lines are equivalent: let t1 = UDB.Map.createThing(new UDB.Vector2D(32, 64), 3001); // Create an Imp let t2 = UDB.Map.createThing([ 32, 64 ], 3001); // Create an Imp let t3 = UDB.Map.createThing({ x: 32, y: 64 }, 3001); // Create an Imp let v = new UDB.Vector2D(32, 64); // Supplying the x and y values let t4 = UDB.Map.createThing(v, 3001); // Create an Imp","title":"Working with vectors"},{"location":"gettingstarted/#vector-arithmetic","text":"It is possible to do elementary arithmetic with vectors, i.e. you can add, substract, multiply, and divide them. let v1 = new UDB.Vector2D(2, 3) + new UDB.Vector2D(4, 5); // Results in new Vector(6, 8) let v2 = new UDB.Vector2D(2, 3) - new UDB.Vector2D(4, 5); // Results in new Vector(-2, -2) let v3 = new UDB.Vector2D(2, 3) * new UDB.Vector2D(4, 5); // Results in new Vector(8, 15) let v4 = new UDB.Vector2D(2, 3) / new UDB.Vector2D(4, 5); // Results in new Vector(0.5, 0.6) This also works with the array and object notation: let v1 = new UDB.Vector2D(2, 3) + [ 4, 5 ]; // Results in new Vector(6, 8) let v2 = new UDB.Vector2D(2, 3) + { x: 4, y: 5 }; // Results in new Vector(6, 8) You can also use only a number as one side of the operation, in which case the operation will be applied to each element of the vector: let v1 = new UDB.Vector2D(2, 3) + 3; // Results in new Vector(5, 6) let v2 = new UDB.Vector2D(2, 3) * 3; // Results in new Vector(6, 9) Attention Vector arithmetic only works if either side of arithmetic operation is of type Vector2D or Vector3D . That means that for example the following code will not result in a vector: let v1 = [ 2, 3 ] + [ 4, 5 ]; // Results in the string \"2, 34, 5\"","title":"Vector arithmetic"},{"location":"gettingstarted/#working-with-map-elements","text":"Map elements (things, sectors, linedefs, sidedefs, vertices) can be accessed through the UDB.Map object. This object has methods that return an array of map elements, for example UDB.Map.getSectors() returns an array of Sector objects, which are are all sectors in the map. There are also methods to get all selected (for example UDB.Map.getSelectedSectors() ) and marked (for example UDB.Map.getMarkedSectors() ), or the currently highlighted (for example UDB.Map.getHighlightedSector() ) map elements. There are also methods to get either the currently selected map elements, or the currently highlighted map elements (for example UDB.Map.getSelectedOrHighlightedSectors() ). These map elements can then be modified, see the documentation for the particular map element type in the API section. Note \"Marking\" a map element is a way to denote that something happened to this map element. For example when using the UDB.Map.drawLines() method all new geometry will be marked. Info UDB differentiates between \"selecting\" and \"highlighting\" map elements. \"Selecting\" means clicking on the map element, \"highlighting\" means just hovering the mouse on (or near) a map element. All the UDB.Map.getSelectedOrHighlighted...() methods behave like UDB usually works, i.e. if at least one map element is selected, the selected map elements will be returned (and the highlighted map element will be ignored), if no map elements are selected the highlighted map element will be returned. In most circumstances it is recommended to use the UDB.Map.getSelectedOrHighlighted...() to stay close to UDB's built-in actions.","title":"Working with map elements"},{"location":"gettingstarted/#creating-new-geometry","text":"New map geometry can be created with the drawLines() method of the UDB.Map object. It accepts an array of coordinates in map space. The coordinates can either by instances of Vector2D , Vector3D , or an array of numbers. Example 1: UDB.Map.drawLines([ new UDB.Vector2D(0, 0), new UDB.Vector2D(64, 0), new UDB.Vector2D(64, 64), new UDB.Vector2D(0, 64), new UDB.Vector2D(0, 0) ]); Example 2: UDB.Map.drawLines([ [ 0, 0 ], [ 64, 0 ], [ 64, 64 ], [ 0, 64 ], [ 0, 0 ] ]); Both examples are equivalent. The advantage of using Vector2D or Vector3D is that they have many math related methods built-in. Another method to draw geometry is using the Pen class - which itself is implemented as a library written in JavaScript. It's inspired by the DoomBuilder X class of the same name. It provides some quality of life features, since it creates coordinates relative to the current position - just like moving a pen around a sheet of paper, or Turtle graphics . Naive implementation of the above example using the Pen class: let p = new Pen(); p.moveTo([0, 0]); p.drawVertex(); p.moveTo([64, 0]); p.drawVertex(); p.moveTo([64, 64]); p.drawVertex(); p.moveTo([0, 64]); p.drawVertex(); p.finishDrawing(); Using the strenghts of the Pen class: let p = new Pen([0, 0]); for(let i=0; i < 4; i++) { p.drawVertex(); p.moveForward(64); p.turnRight(); } p.finishDrawing();","title":"Creating new geometry"},{"location":"gettingstarted/#ending-scripts-prematurely","text":"Normally a script ends when the last instruction is executed. But there can be situations where you want to end a script early. UDB.exit() : this global function ends the script with success. It can optionally take a string argument that is shown in the status bar upon ending the script UDB.die() : this global function ends the script with a failure. This means that it will undo any changes the script has made. It can optionally take a string argument that is shown in the status bar upon ending the script throw : throws an exception. Only ends the script if it's not caught in a try / catch block. If not caught it'll end the script with a failure. This means that it will undo any changes the script has made. The string given as a parameter is shown in the status bar upon ending the script let sectors = UDB.Map.getSelectedSectors(); if(sectors.length == 0) UDB.die('You have to select at least one sector'); UDB.exit('There were ' + sectors.length + ' sectors selected'); throw 'This part of the script should never be reached!';","title":"Ending scripts prematurely"},{"location":"gettingstarted/#communicating-with-the-user","text":"Sometimes you might want to let the script directly communicate with the user. To do that there are two functions, UDB.showMessage() and UDB.showMessageYesNo() . UDB.showMessage() : shows a message box with an \"OK\" button and the text given as the parameter UDB.showMessage('Hello, world!'); UDB.showMessageYesNo() : shows a message box with an \"Yes\" and \"No\" button and the text given as the parameter. Returns true if the \"Yes\" button was clicked, and false if the \"No\" button was clicked if(UDB.showMessageYesNo('Are you sure you want to replace all imps with Arch-Viles? That\\'s not remotely fair!')) { UDB.Map.getThings().filter(t => t.type == 3001).forEach(t => t.type=64); } For long-running scripts it's also possible to report the progress to the user using the UDB.setProgress() method, which accepts values from 0 to 100. For example the following code will set the progress bar to 25%: UDB.setProgress(25); Additional output can be shown using the UDB.log() method, which will add a line of text to the log in the running script dialog: UDB.log('Hello, world!');","title":"Communicating with the user"}]}